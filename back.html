 <!DOCTYPE html> 

 <html lang="en"> 

 <head> 

 ย ย <meta charset="UTF-8"> 

 ย ย <meta name="viewport" content="width=device-width, initial-scale=1.0"> 

 ย ย <title>Klondike Solitaire Deluxe</title> 

 ย ย <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script> 

 ย ย <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script> 

 ย ย <style> 

 ย ย ย ย :root { 

 ย ย ย ย ย ย --board-bg: #006400; 

 ย ย ย ย ย ย --card-bg: #f8f8f8; 

 ย ย ย ย ย ย --card-border: #333333; 

 ย ย ย ย ย ย --card-placeholder: rgba(255, 255, 255, 0.2); 

 ย ย ย ย ย ย --card-width: 100px; 

 ย ย ย ย ย ย --card-height: 140px; 

 ย ย ย ย ย ย --gap: 15px; 

 ย ย ย ย ย ย --border-radius: 8px; 

 ย ย ย ย ย ย --xp-color: #007bff; 

 ย ย ย ย ย ย --card-overlap: 28px;ย 

 ย ย ย ย } 



 ย ย ย ย body { 

 ย ย ย ย ย ย font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 

 ย ย ย ย ย ย display: flex; 

 ย ย ย ย ย ย flex-direction: column; 

 ย ย ย ย ย ย align-items: center; 

 ย ย ย ย ย ย justify-content: flex-start; 

 ย ย ย ย ย ย min-height: 100vh; 

 ย ย ย ย ย ย margin: 0; 

 ย ย ย ย ย ย padding: 15px; 

 ย ย ย ย ย ย box-sizing: border-box; 

 ย ย ย ย ย ย overflow: hidden; 

 ย ย ย ย ย ย -webkit-user-select: none; 

 ย ย ย ย ย ย -ms-user-select: none; 

 ย ย ย ย ย ย user-select: none; 

 ย ย ย ย ย ย /* Style for full-screen background */ 

 ย ย ย ย ย ย background-size: cover; 

 ย ย ย ย ย ย background-position: center; 

 ย ย ย ย ย ย transition: background 0.5s ease; 

 ย ย ย ย } 

 ย ย ย ยย 

 ย ย ย ย #starfield-canvas, #lavalamp-canvas, #ocean-canvas, #matrix-canvas, #geometric-canvas, #fire-canvas, #rain-canvas, #hyperspace-canvas, #plasma-canvas, #forest-canvas, #neongrid-canvas, #sakura-canvas, #quantum-canvas, #digitalrain-canvas, #sands-canvas, #inkblot-canvas, #cosmic-canvas, #musicviz-canvas, #bioforest-canvas, #stainedglass-canvas, #watery-canvas, #swarm-canvas, #glitch-canvas, #aurora-canvas, #constellation-canvas, #synthwave-canvas, #nebula-canvas, #jungle-canvas, #cityscape-canvas, #paint-canvas, #laserGrid-canvas, #neonPalms-canvas, #memphis-canvas, #cassette-canvas, #eightBitCity-canvas { 

 ย ย ย ย ย ย position: fixed; 

 ย ย ย ย ย ย top: 0; 

 ย ย ย ย ย ย left: 0; 

 ย ย ย ย ย ย width: 100%; 

 ย ย ย ย ย ย height: 100%; 

 ย ย ย ย ย ย z-index: -1; 

 ย ย ย ย ย ย display: none; 

 ย ย ย ย } 

 ย ย ย ย #starfield-canvas, #matrix-canvas, #hyperspace-canvas, #neongrid-canvas, #digitalrain-canvas, #cosmic-canvas, #swarm-canvas, #glitch-canvas, #constellation-canvas, #synthwave-canvas, #nebula-canvas, #laserGrid-canvas, #neonPalms-canvas, #eightBitCity-canvas, #cityscape-canvas, #cassette-canvas { background-color: #000; } 

 ย ย ย ย #plasma-canvas, #forest-canvas, #quantum-canvas, #bioforest-canvas, #aurora-canvas, #jungle-canvas { background-color: #111; } 





 ย ย ย ย /* Title Screen */ 

 ย ย ย ย #title-screen { 

 ย ย ย ย ย ย display: flex; 

 ย ย ย ย ย ย flex-direction: column; 

 ย ย ย ย ย ย align-items: center; 

 ย ย ย ย ย ย justify-content: center; 

 ย ย ย ย ย ย position: fixed; 

 ย ย ย ย ย ย top: 0; left: 0; width: 100%; height: 100%; 

 ย ย ย ย ย ย background: var(--board-bg); 

 ย ย ย ย ย ย z-index: 100; 

 ย ย ย ย ย ย transition: opacity 0.5s ease-out, visibility 0.5s; 

 ย ย ย ย } 

 ย ย ย ย #title-screen.hidden { 

 ย ย ย ย ย ย opacity: 0; 

 ย ย ย ย ย ย visibility: hidden; 

 ย ย ย ย } 

 ย ย ย ย #title-screen h1 { 

 ย ย ย ย ย ย font-size: clamp(2rem, 5vw, 4rem); 

 ย ย ย ย ย ย color: white; 

 ย ย ย ย ย ย text-shadow: 3px 3px 5px rgba(0,0,0,0.5); 

 ย ย ย ย ย ย z-index: 10; 

 ย ย ย ย ย ย animation: float 5s ease-in-out infinite; 

 ย ย ย ย } 

 ย ย ย ย #title-screen button { 

 ย ย ย ย ย ย padding: 15px 30px; 

 ย ย ย ย ย ย font-size: 24px; 

 ย ย ย ย ย ย cursor: pointer; 

 ย ย ย ย ย ย border-radius: var(--border-radius); 

 ย ย ย ย ย ย border: none; 

 ย ย ย ย ย ย background-color: #4CAF50; 

 ย ย ย ย ย ย color: white; 

 ย ย ย ย ย ย box-shadow: 0 4px 10px rgba(0,0,0,0.3); 

 ย ย ย ย ย ย transition: all 0.3s; 

 ย ย ย ย ย ย z-index: 10; 

 ย ย ย ย ย ย animation: float 5s ease-in-out 0.5s infinite; 

 ย ย ย ย } 

 ย ย ย ย #title-screen button:hover { 

 ย ย ย ย ย ย transform: scale(1.05); 

 ย ย ย ย ย ย background-color: #45a049; 

 ย ย ย ย } 

 ย ย ย ย .title-cards { 

 ย ย ย ย ย ย position: absolute; 

 ย ย ย ย ย ย width: 100%; 

 ย ย ย ย ย ย height: 100%; 

 ย ย ย ย ย ย overflow: hidden; 

 ย ย ย ย ย ย perspective: 1000px; 

 ย ย ย ย } 

 ย ย ย ย .title-card { 

 ย ย ย ย ย ย position: absolute; 

 ย ย ย ย ย ย top: 50%; 

 ย ย ย ย ย ย left: 50%; 

 ย ย ย ย ย ย width: var(--card-width); 

 ย ย ย ย ย ย height: var(--card-height); 

 ย ย ย ย ย ย transform-style: preserve-3d; 

 ย ย ย ย ย ย transition: transform 1s; 

 ย ย ย ย ย ย animation: fanOut 2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; 

 ย ย ย ย } 

 ย ย ย ย .title-card-inner { 

 ย ย ย ย ย ย position: relative; 

 ย ย ย ย ย ย width: 100%; 

 ย ย ย ย ย ย height: 100%; 

 ย ย ย ย ย ย transform-style: preserve-3d; 

 ย ย ย ย ย ย animation: flip 2s ease-in-out forwards; 

 ย ย ย ย ย ย animation-delay: calc(var(--i) * 0.2s + 1s); 

 ย ย ย ย } 

 ย ย ย ย .title-card-front, .title-card-back { 

 ย ย ย ย ย ย position: absolute; 

 ย ย ย ย ย ย width: 100%; 

 ย ย ย ย ย ย height: 100%; 

 ย ย ย ย ย ย backface-visibility: hidden; 

 ย ย ย ย ย ย border-radius: var(--border-radius); 

 ย ย ย ย } 

 ย ย ย ย .title-card-front { 

 ย ย ย ย ย ย background: var(--card-bg); 

 ย ย ย ย ย ย border: 1px solid black; 

 ย ย ย ย ย ย display: flex; 

 ย ย ย ย ย ย justify-content: center; 

 ย ย ย ย ย ย align-items: center; 

 ย ย ย ย ย ย font-size: 40px; 

 ย ย ย ย } 

 ย ย ย ย .title-card-back { 

 ย ย ย ย ย ย background: linear-gradient(45deg, #005A9C, #003D6B); 

 ย ย ย ย ย ย border: 5px solid white; 

 ย ย ย ย ย ย transform: rotateY(180deg); 

 ย ย ย ย } 

 ย ย ย ย @keyframes fanOut { 

 ย ย ย ย ย ย from { transform: translate(-50%, -50%) rotate(0deg) scale(0); } 

 ย ย ย ย ย ย to { transform: translate(-50%, -50%) rotate(var(--rot)) translateY(-150px) scale(1); } 

 ย ย ย ย } 

 ย ย ย ย @keyframes flip { 

 ย ย ย ย ย ย from { transform: rotateY(180deg); } 

 ย ย ย ย ย ย to { transform: rotateY(0deg); } 

 ย ย ย ย } 

 ย ย ย ย @keyframes float { 

 ย ย ย ย ย ย 0%, 100% { transform: translateY(0); } 

 ย ย ย ย ย ย 50% { transform: translateY(-10px); } 

 ย ย ย ย } 



 ย ย ย ย /* Main Game Layout */ 

 ย ย ย ย #game-container { 

 ย ย ย ย ย ย display: none; 

 ย ย ย ย ย ย flex-direction: column; 

 ย ย ย ย ย ย align-items: center; 

 ย ย ย ย ย ย width: 100%; 

 ย ย ย ย } 

 ย ย ย ยย 

 ย ย ย ย #top-bar { 

 ย ย ย ย ย ย display: flex; 

 ย ย ย ย ย ย flex-wrap: wrap; 

 ย ย ย ย ย ย justify-content: center; 

 ย ย ย ย ย ย align-items: center; 

 ย ย ย ย ย ย gap: 15px; 

 ย ย ย ย ย ย width: 100%; 

 ย ย ย ย ย ย margin-bottom: 15px; 

 ย ย ย ย ย ย padding: 5px; 

 ย ย ย ย ย ย background: rgba(0,0,0,0.2); 

 ย ย ย ย ย ย border-radius: var(--border-radius); 

 ย ย ย ย ย ย box-sizing: border-box; 

 ย ย ย ย } 



 ย ย ย ย #combo-canvas { 

 ย ย ย ย ย ย position: fixed; 

 ย ย ย ย ย ย top: 0; 

 ย ย ย ย ย ย left: 0; 

 ย ย ย ย ย ย width: 100%; 

 ย ย ย ย ย ย height: 100%; 

 ย ย ย ย ย ย pointer-events: none; 

 ย ย ย ย ย ย z-index: 50; 

 ย ย ย ย } 

 ย ย ย ยย 

 ย ย ย ย #player-stats-panel { 

 ย ย ย ย ย ย display: flex; 

 ย ย ย ย ย ย flex-direction: row; 

 ย ย ย ย ย ย flex-wrap: wrap; 

 ย ย ย ย ย ย justify-content: center; 

 ย ย ย ย ย ย align-items: center; 

 ย ย ย ย ย ย gap: 10px; 

 ย ย ย ย } 



 ย ย ย ย .game-controls { 

 ย ย ย ย ย ย display: flex; 

 ย ย ย ย ย ย flex-direction: row; 

 ย ย ย ย ย ย flex-wrap: wrap; 

 ย ย ย ย ย ย justify-content: center; 

 ย ย ย ย ย ย align-items: center; 

 ย ย ย ย ย ย gap: 8px; 

 ย ย ย ย } 



 ย ย ย ย #xp-container {ย 

 ย ย ย ย ย ย display: flex; 

 ย ย ย ย ย ย align-items: center; 

 ย ย ย ย ย ย gap: 8px; 

 ย ย ย ย } 

 ย ย ย ย #xp-bar-container { 

 ย ย ย ย ย ย width: 80px; 

 ย ย ย ย ย ย height: 15px; 

 ย ย ย ย ย ย background-color: #e9ecef; 

 ย ย ย ย ย ย border-radius: var(--border-radius); 

 ย ย ย ย ย ย overflow: hidden; 

 ย ย ย ย ย ย display: flex; 

 ย ย ย ย ย ย flex-direction: row; 

 ย ย ย ย } 

 ย ย ย ย #xp-bar { 

 ย ย ย ย ย ย height: 100%; 

 ย ย ย ย ย ย width: 0%; 

 ย ย ย ย ย ย background-color: var(--xp-color); 

 ย ย ย ย ย ย transition: width 0.5s ease-in-out; 

 ย ย ย ย } 

 ย ย ย ย #level-text, #xp-text, #game-timer, #achievement-score-display {ย 

 ย ย ย ย ย ย font-weight: bold; 

 ย ย ย ย ย ย font-size: 0.9em; 

 ย ย ย ย ย ย color: #fff; 

 ย ย ย ย ย ย text-shadow: 1px 1px 2px rgba(0,0,0,0.5); 

 ย ย ย ย } 

 ย ย ย ย #xp-text { font-size: 0.7em; } 



 ย ย ย ย .game-controls button, #options-btn, #fullscreen-btn, #mute-btn { 

 ย ย ย ย ย ย padding: 4px 8px; 

 ย ย ย ย ย ย font-size: 12px; 

 ย ย ย ย ย ย cursor: pointer; 

 ย ย ย ย ย ย border-radius: var(--border-radius); 

 ย ย ย ย ย ย border: none; 

 ย ย ย ย ย ย background-color: #4CAF50; 

 ย ย ย ย ย ย color: white; 

 ย ย ย ย ย ย transition: all 0.3s; 

 ย ย ย ย ย ย box-shadow: 0 2px 5px rgba(0,0,0,0.2); 

 ย ย ย ย ย ย display: flex; 

 ย ย ย ย ย ย align-items: center; 

 ย ย ย ย ย ย justify-content: center; 

 ย ย ย ย } 

 ย ย ย ย #options-btn, #fullscreen-btn, #mute-btn { background-color: #6c757d; font-size: 14px; } 

 ย ย ย ย #options-btn:hover, #fullscreen-btn:hover, #mute-btn:hover { background-color: #5a6268; } 

 ย ย ย ย #hint-btn { background-color: #ffc107; color: black; } 

 ย ย ย ย #hint-btn:hover { background-color: #e0a800; } 

 ย ย ย ย #hint-btn:disabled, #undo-btn:disabled { background-color: #6c757d; cursor: not-allowed; } 

 ย ย ย ย #undo-btn { background-color: #17a2b8; } 

 ย ย ย ย #undo-btn:hover { background-color: #138496; } 

 ย ย ย ย #autocomplete-btn { background-color: #007bff; } 

 ย ย ย ย #autocomplete-btn:hover { background-color: #0069d9; } 

 ย ย ย ย #autocomplete-btn.hidden { display: none; } 

 ย ย ย ย #fullscreen-btn svg, #mute-btn svg { 

 ย ย ย ย ย ย width: 14px; 

 ย ย ย ย ย ย height: 14px; 

 ย ย ย ย ย ย fill: white; 

 ย ย ย ย } 



 ย ย ย ย #message-box { font-size: 18px; font-weight: bold; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); min-height: 25px; width: 100%; text-align: center; margin-bottom: 10px; } 



 ย ย ย ย #game-board-container { 

 ย ย ย ย ย ย display: flex; 

 ย ย ย ย ย ย flex-direction: column; 

 ย ย ย ย ย ย align-items: center; 

 ย ย ย ย } 



 ย ย ย ย #game-board {ย 

 ย ย ย ย ย ย display: grid;ย 

 ย ย ย ย ย ย grid-template-columns: repeat(7, var(--card-width));ย 

 ย ย ย ย ย ย gap: var(--gap);ย 

 ย ย ย ย ย ย background-color: rgba(0, 80, 0, 0.6);ย 

 ย ย ย ย ย ย padding: var(--gap);ย 

 ย ย ย ย ย ย border-radius: var(--border-radius);ย 

 ย ย ย ย ย ย box-shadow: 0 10px 20px rgba(0,0,0,0.2);ย 

 ย ย ย ย ย ย width: fit-content;ย 

 ย ย ย ย } 

 ย ย ย ย .upper-area { grid-column: 1 / 8; display: flex; justify-content: space-between; margin-bottom: var(--gap); } 

 ย ย ย ย .stock-waste-area, .foundation-area { display: flex; gap: var(--gap); } 

 ย ย ย ย .pile, .card { width: var(--card-width); height: var(--card-height); border-radius: var(--border-radius); box-sizing: border-box; } 

 ย ย ย ย .pile { border: 2px dashed var(--card-placeholder); position: relative; display: flex; justify-content: center; align-items: center; } 

 ย ย ย ย .pile.stock::before { content: 'โป๏ธ'; font-size: 40px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 0.5; } 



 ย ย ย ย .card { position: absolute; cursor: grab; background-color: var(--card-bg); border: 1px solid var(--card-border); display: flex; flex-direction: column; justify-content: space-between; padding: 5px; font-weight: bold; user-select: none; transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s; box-shadow: 0 4px 8px rgba(0,0,0,0.15); } 

 ย ย ย ย .card.red { color: #d90429; } 

 ย ย ย ย .card.black { color: #000000; } 

 ย ย ย ย .tableau-pile { position: relative; width: var(--card-width); min-height: var(--card-height); } 

 ย ย ย ย .tableau-pile .card { position: absolute; top: 0; left: 0; } 

 ย ย ย ยย 

 ย ย ย ย .card .card-value { padding: 5px; font-size: clamp(14px, calc(var(--card-width) * 0.28), 28px); line-height: 1; } 

 ย ย ย ย .card .card-value.bottom { align-self: flex-end; transform: rotate(180deg); } 

 ย ย ย ย .card .card-center-suit { display: none; } 

 ย ย ย ย [data-face-style="easy-see"] .card.is-top-card .card-value { display: none; } 

 ย ย ย ย [data-face-style="easy-see"] .card.is-top-card .card-center-suit { display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; font-size: clamp(60px, calc(var(--card-width) * 1.2), 120px); line-height: 1; position: relative; } 

 ย ย ย ย [data-face-style="easy-see"] .card.is-top-card .card-center-value { position: absolute; font-size: clamp(24px, calc(var(--card-width) * 0.48), 48px); color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); } 



 ย ย ย ย .card.face-down { color: transparent; border: 5px solid white; background-size: cover; background-position: center; } 

 ย ย ย ยย 

 ย ย ย ย #fireworks-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; } 

 ย ย ย ย .firework { position: absolute; font-size: 40px; opacity: 0; animation: shootUp 1s ease-out forwards; } 

 ย ย ย ย @keyframes shootUp { to { transform: translateY(-80vh); opacity: 1; } } 

 ย ย ย ย .card.win-animate { display: none; } 

 ย ย ย ย .hint-glow { animation: glow 1.5s infinite; } 

 ย ย ย ย @keyframes glow { 50% { box-shadow: 0 0 20px 10px #ffc107; } } 



 ย ย ย ย /* Modals */ 

 ย ย ย ย .modal-overlay { display: none; position: fixed; z-index: 1001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); align-items: center; justify-content: center; } 

 ย ย ย ย .modal-content { background-color: #fefefe; margin: auto; padding: 20px; border: 1px solid #888; width: 90%; max-width: 800px; border-radius: var(--border-radius); max-height: 80vh; overflow-y: auto; position: relative; } 

 ย ย ย ย .close-btn { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; } 

 ย ย ย ย .options-section { margin-top: 20px; } 

 ย ย ย ย .options-section h4 { margin-bottom: 10px; } 

 ย ย ย ย .options-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; margin-top: 10px; } 

 ย ย ย ย .options-grid-item { width: 100px; height: 140px; border-radius: var(--border-radius); cursor: pointer; position: relative; background-size: cover; background-position: center; border: 2px solid transparent; } 

 ย ย ย ย .options-grid-item.locked::after { content: '๐'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; color: white; background: rgba(0,0,0,0.5); width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; border-radius: var(--border-radius); } 

 ย ย ย ย .options-grid-item.selected { box-shadow: 0 0 0 4px #007bff; border-color: #007bff; } 

 ย ย ย ยย 

 ย ย ย ย #unlock-modal .modal-content, #draw-select-modal .modal-content, #card-style-modal .modal-content, #reset-confirm-modal .modal-content { max-width: 500px; text-align: center; } 

 ย ย ย ย #unlock-modal h2, #draw-select-modal h2, #card-style-modal h2, #reset-confirm-modal h2 { font-size: 2em; color: var(--xp-color); } 

 ย ย ย ย #reset-confirm-modal h2 { color: #d90429; } 

 ย ย ย ย #unlock-modal p, #draw-select-modal p, #card-style-modal p, #reset-confirm-modal p { font-size: 1.2em; margin: 20px 0; } 

 ย ย ย ย #unlock-modal button, #reset-confirm-modal button { padding: 10px 30px; font-size: 1.2em; } 

 ย ย ย ยย 

 ย ย ย ย .modal-buttons { display: flex; justify-content: center; gap: 20px; margin-top: 20px; } 

 ย ย ย ย .modal-buttons button { padding: 10px 30px; font-size: 1.2em; cursor: pointer; border-radius: var(--border-radius); border: none; color: white; box-shadow: 0 2px 5px rgba(0,0,0,0.2); } 

 ย ย ย ย #draw-1-btn, #normal-style-btn, #unlock-apply-btn { background-color: #007bff; } 

 ย ย ย ย #draw-3-btn, #easy-see-btn { background-color: #4CAF50; } 

 ย ย ย ย #unlock-close-btn, #reset-cancel-btn { background-color: #6c757d; } 

 ย ย ย ย #reset-confirm-btn { background-color: #d90429; } 

 ย ย ย ยย 

 ย ย ย ย #achievement-modal .modal-content { max-width: 600px; } 

 ย ย ย ย .achievement-entry { display: flex; align-items: center; margin-bottom: 10px; opacity: 0.5; } 

 ย ย ย ย .achievement-entry.unlocked { opacity: 1; } 

 ย ย ย ย .achievement-entry-icon { font-size: 30px; margin-right: 15px; } 

 ย ย ย ย .achievement-entry-details h4 { margin: 0; } 

 ย ย ย ย .achievement-entry-details p { margin: 0; font-size: 0.9em; color: #6c757d; } 



 ย ย ย ย #achievement-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10000; display: flex; flex-direction: column-reverse; gap: 10px; pointer-events: none; } 

 ย ย ย ย .achievement-toast { display: flex; align-items: center; background: rgba(0, 0, 0, 0.8); color: white; padding: 10px 20px; border-radius: 50px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); transform: translateY(150%); opacity: 0; animation: slide-in-out 5s forwards; } 

 ย ย ย ย .achievement-icon { font-size: 30px; margin-right: 15px; } 

 ย ย ย ย .achievement-details h4 { margin: 0; font-size: 1em; color: #10e010; } 

 ย ย ย ย .achievement-details p { margin: 0; font-size: 0.8em; } 

 ย ย ย ย @keyframes slide-in-out { 0% { transform: translateY(150%); opacity: 0; } 10% { transform: translateY(0); opacity: 1; } 90% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(150%); opacity: 0; } } 



 ย ย ย ย footer { margin-top: 20px; color: #6c757d; font-size: 14px; } 



 ย ย ย ย #flash-overlay { 

 ย ย ย ย ย ย position: fixed; 

 ย ย ย ย ย ย top: 0; 

 ย ย ย ย ย ย left: 0; 

 ย ย ย ย ย ย width: 100%; 

 ย ย ย ย ย ย height: 100%; 

 ย ย ย ย ย ย background-color: rgba(255, 255, 255, 0.8); 

 ย ย ย ย ย ย opacity: 0; 

 ย ย ย ย ย ย pointer-events: none; 

 ย ย ย ย ย ย z-index: 9998; 

 ย ย ย ย } 



 ย ย ย ย #flash-overlay.flash { 

 ย ย ย ย ย ย animation: white-flash 0.3s ease-out; 

 ย ย ย ย } 



 ย ย ย ย @keyframes white-flash { 

 ย ย ย ย ย ย 0% { opacity: 1; } 

 ย ย ย ย ย ย 100% { opacity: 0; } 

 ย ย ย ย } 



 ย ย ย ย /* --- Animated Card Back Keyframes --- */ 

 ย ย ย ย @keyframes vortex { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } 

 ย ย ย ย @keyframes scanlines { 0% { background-position: 0 0; } 100% { background-position: 0 50px; } } 

 ย ย ย ย @keyframes pulse { 0%, 100% { box-shadow: inset 0 0 20px #fff; } 50% { box-shadow: inset 0 0 30px #0ff; } } 

 ย ย ย ย @keyframes rainbow-shift { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } } 

 ย ย ย ย @keyframes liquid-metal { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } } 

 ย ย ย ย @keyframes twinkle-stars { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } } 

 ย ย ย ย @keyframes glacial-ice { 0% { background-position: 0% 0%; } 100% { background-position: 50px 50px; } } 

 ย ย ย ย @keyframes arcane-runes { 0%, 100% { opacity: 0.2; } 50% { opacity: 0.8; } } 

 ย ย ย ย @keyframes molten-core { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } } 

 ย ย ย ย @keyframes circuitry { 0% { background-position: 0 0; } 100% { background-position: -100px 0; } } 



 ย ย ย ย /* --- Animated Card Back Styles --- */ 

 ย ย ย ย [data-back-style="animated-vortex"] .face-down { background: conic-gradient(from 0.5turn at 50% 50%, #000, #2a004f, #6a0dad, #9400d3, #4b0082, #000); animation: vortex 5s linear infinite; } 

 ย ย ย ย [data-back-style="animated-scanlines"] .face-down { background-color: #111; background-image: linear-gradient(rgba(0, 255, 0, 0.3) 1px, transparent 1px); background-size: 100% 4px; animation: scanlines 1s linear infinite; } 

 ย ย ย ย [data-back-style="animated-pulse"] .face-down { background-color: #022; animation: pulse 2s ease-in-out infinite; } 

 ย ย ย ย [data-back-style="animated-rainbow"] .face-down { background: linear-gradient(90deg, red, orange, yellow, green, blue, indigo, violet, red); background-size: 200% 200%; animation: rainbow-shift 5s ease infinite; } 

 ย ย ย ย [data-back-style="animated-circuitry"] .face-down { background-color: #010; background-image: linear-gradient(45deg, #0f0 25%, transparent 25%, transparent 75%, #0f0 75%, #0f0), linear-gradient(-45deg, #0f0 25%, transparent 25%, transparent 75%, #0f0 75%, #0f0); background-size: 50px 50px; animation: circuitry 3s linear infinite; } 

 ย ย ย ย [data-back-style="animated-liquid"] .face-down { background: linear-gradient(60deg, #ccc, #fff, #999, #eee, #ccc); background-size: 400% 400%; animation: liquid-metal 4s ease infinite; } 

 ย ย ย ย [data-back-style="animated-stars"] .face-down { background-color: #000; background-image: radial-gradient(white 1px, transparent 1px), radial-gradient(white 1px, transparent 1px); background-size: 50px 50px, 25px 25px; background-position: 0 0, 12.5px 12.5px; animation: twinkle-stars 3s ease-in-out infinite; } 

 ย ย ย ย [data-back-style="animated-ice"] .face-down { background-color: #aef; background-image: linear-gradient(30deg, #fff 12%, transparent 12.5%, transparent 87%, #fff 87.5%, #fff), linear-gradient(150deg, #fff 12%, transparent 12.5%, transparent 87%, #fff 87.5%, #fff), linear-gradient(30deg, #fff 12%, transparent 12.5%, transparent 87%, #fff 87.5%, #fff), linear-gradient(150deg, #fff 12%, transparent 12.5%, transparent 87%, #fff 87.5%, #fff); background-size: 40px 70px; background-position: 0 0, 0 0, 20px 35px, 20px 35px; animation: glacial-ice 10s linear infinite; } 

 ย ย ย ย [data-back-style="animated-runes"] .face-down { background-color: #2c003e; color: #ff00ff; text-align: center; font-size: 40px; line-height: 140px; font-family: 'Times New Roman', serif; animation: arcane-runes 4s ease-in-out infinite; } 

 ย ย ย ย [data-back-style="animated-runes"] .face-down::before { content: 'แ'; } 

 ย ย ย ย [data-back-style="animated-molten"] .face-down { background: linear-gradient(45deg, #ff4500, #ff8c00, #ffd700, #ff4500); background-size: 400% 400%; animation: molten-core 3s ease infinite; } 



 ย ย ย ย /* Responsive Layout */ 

 ย ย ย ย @media (max-width: 640px) { 

 ย ย ย ย ย ย :root { --card-width: calc((100vw - 45px) / 7); --card-height: calc(var(--card-width) * 1.4); --gap: 5px; } 

 ย ย ย ย ย ย #top-bar { gap: 5px; } 

 ย ย ย ย } 

 ย ย </style> 

 </head> 

 <body> 

 ย ย <canvas id="starfield-canvas"></canvas> 

 ย ย <canvas id="lavalamp-canvas"></canvas> 

 ย ย <canvas id="ocean-canvas"></canvas> 

 ย ย <canvas id="matrix-canvas"></canvas> 

 ย ย <canvas id="geometric-canvas"></canvas> 

 ย ย <canvas id="fire-canvas"></canvas> 

 ย ย <canvas id="rain-canvas"></canvas> 

 ย ย <canvas id="hyperspace-canvas"></canvas> 

 ย ย <canvas id="plasma-canvas"></canvas> 

 ย ย <canvas id="forest-canvas"></canvas> 

 ย ย <canvas id="neongrid-canvas"></canvas> 

 ย ย <canvas id="sakura-canvas"></canvas> 

 ย ย <canvas id="quantum-canvas"></canvas> 

 ย ย <canvas id="digitalrain-canvas"></canvas> 

 ย ย <canvas id="sands-canvas"></canvas> 

 ย ย <canvas id="inkblot-canvas"></canvas> 

 ย ย <canvas id="cosmic-canvas"></canvas> 

 ย ย <canvas id="musicviz-canvas"></canvas> 

 ย ย <canvas id="bioforest-canvas"></canvas> 

 ย ย <canvas id="stainedglass-canvas"></canvas> 

 ย ย <canvas id="watery-canvas"></canvas> 

 ย ย <canvas id="swarm-canvas"></canvas> 

 ย ย <canvas id="glitch-canvas"></canvas> 

 ย ย <canvas id="aurora-canvas"></canvas> 

 ย ย <canvas id="constellation-canvas"></canvas> 

 ย ย <canvas id="synthwave-canvas"></canvas> 

 ย ย <canvas id="nebula-canvas"></canvas> 

 ย ย <canvas id="jungle-canvas"></canvas> 

 ย ย <canvas id="cityscape-canvas"></canvas> 

 ย ย <canvas id="paint-canvas"></canvas> 

 ย ย <canvas id="laserGrid-canvas"></canvas> 

 ย ย <canvas id="neonPalms-canvas"></canvas> 

 ย ย <canvas id="memphis-canvas"></canvas> 

 ย ย <canvas id="cassette-canvas"></canvas> 

 ย ย <canvas id="eightBitCity-canvas"></canvas> 

 ย ยย 

 ย ย <div id="flash-overlay"></div> 



 ย ย <div id="title-screen"> 

 ย ย ย ย <div class="title-cards"></div> 

 ย ย ย ย <h1>Klondike Solitaire</h1> 

 ย ย ย ย <button id="start-game-btn">Start Game</button> 

 ย ย </div> 



 ย ย <div id="game-container"> 

 ย ย ย ย <canvas id="combo-canvas"></canvas> 

 ย ย ย ยย 

 ย ย ย ย <div id="top-bar"> 

 ย ย ย ย ย ย <div id="player-stats-panel"> 

 ย ย ย ย ย ย ย ย <div id="xp-container"> 

 ย ย ย ย ย ย ย ย ย ย <span id="level-text">Level 1</span> 

 ย ย ย ย ย ย ย ย ย ย <div id="xp-bar-container"> 

 ย ย ย ย ย ย ย ย ย ย ย ย <div id="xp-bar"></div> 

 ย ย ย ย ย ย ย ย ย ย </div> 

 ย ย ย ย ย ย ย ย ย ย <span id="xp-text">0/10 XP</span> 

 ย ย ย ย ย ย ย ย </div> 

 ย ย ย ย ย ย ย ย <div id="achievement-score-display">๐ 0</div> 

 ย ย ย ย ย ย ย ย <div id="game-timer">00:00</div> 

 ย ย ย ย ย ย </div> 

 ย ย ย ย ย ย <div class="game-controls"> 

 ย ย ย ย ย ย ย ย <button id="new-game-btn">New Game</button> 

 ย ย ย ย ย ย ย ย <button id="autocomplete-btn" class="hidden">Autocomplete</button> 

 ย ย ย ย ย ย ย ย <button id="undo-btn">โ Undo (0)</button> 

 ย ย ย ย ย ย ย ย <button id="hint-btn">๐ก Hint (0)</button> 

 ย ย ย ย ย ย ย ย <button id="achievements-btn">๐</button> 

 ย ย ย ย ย ย ย ย <button id="options-btn">โ๏ธ</button> 

 ย ย ย ย ย ย ย ย <button id="fullscreen-btn"> 

 ย ย ย ย ย ย ย ย ย ย <svg id="fullscreen-icon" viewBox="0 0 24 24"> 

 ย ย ย ย ย ย ย ย ย ย ย ย <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/> 

 ย ย ย ย ย ย ย ย ย ย </svg> 

 ย ย ย ย ย ย ย ย ย ย <svg id="exit-fullscreen-icon" viewBox="0 0 24 24" style="display: none;"> 

 ย ย ย ย ย ย ย ย ย ย ย ย <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/> 

 ย ย ย ย ย ย ย ย ย ย </svg> 

 ย ย ย ย ย ย ย ย </button> 

 ย ย ย ย ย ย ย ย <button id="mute-btn"> 

 ย ย ย ย ย ย ย ย ย ย <svg id="unmuted-icon" viewBox="0 0 24 24"> 

 ย ย ย ย ย ย ย ย ย ย ย ย <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/> 

 ย ย ย ย ย ย ย ย ย ย </svg> 

 ย ย ย ย ย ย ย ย ย ย <svg id="muted-icon" viewBox="0 0 24 24" style="display: none;"> 

 ย ย ย ย ย ย ย ย ย ย ย ย <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/> 

 ย ย ย ย ย ย ย ย ย ย </svg> 

 ย ย ย ย ย ย ย ย </button> 

 ย ย ย ย ย ย </div> 

 ย ย ย ย </div> 

 ย ย ย ยย 

 ย ย ย ย <div id="game-board-container"> 

 ย ย ย ย ย ย <div id="message-box"></div> 

 ย ย ย ย ย ย <div id="game-board"> 

 ย ย ย ย ย ย ย ย <div class="upper-area"> 

 ย ย ย ย ย ย ย ย ย ย <div class="stock-waste-area"> 

 ย ย ย ย ย ย ย ย ย ย ย ย <div class="pile stock" id="stock-pile"></div> 

 ย ย ย ย ย ย ย ย ย ย ย ย <div class="pile" id="waste-pile"></div> 

 ย ย ย ย ย ย ย ย ย ย </div> 

 ย ย ย ย ย ย ย ย ย ย <div class="foundation-area"> 

 ย ย ย ย ย ย ย ย ย ย ย ย <div class="pile" id="foundation-0"></div><div class="pile" id="foundation-1"></div> 

 ย ย ย ย ย ย ย ย ย ย ย ย <div class="pile" id="foundation-2"></div><div class="pile" id="foundation-3"></div> 

 ย ย ย ย ย ย ย ย ย ย </div> 

 ย ย ย ย ย ย ย ย </div> 

 ย ย ย ย ย ย ย ย <div class="tableau-pile" id="tableau-0"></div><div class="tableau-pile" id="tableau-1"></div> 

 ย ย ย ย ย ย ย ย <div class="tableau-pile" id="tableau-2"></div><div class="tableau-pile" id="tableau-3"></div> 

 ย ย ย ย ย ย ย ย <div class="tableau-pile" id="tableau-4"></div><div class="tableau-pile" id="tableau-5"></div> 

 ย ย ย ย ย ย ย ย <div class="tableau-pile" id="tableau-6"></div> 

 ย ย ย ย ย ย </div> 

 ย ย ย ย </div> 

 ย ย ย ยย 

 ย ย ย ย <footer style="margin-top: auto; padding-top: 20px;">Created by PM Lewis</footer> 

 ย ย </div> 



 ย ย <div id="draw-select-modal" class="modal-overlay"> 

 ย ย ย ย <div class="modal-content"> 

 ย ย ย ย ย ย <h2>Choose Draw Style</h2> 

 ย ย ย ย ย ย <p>Select whether to draw one or three cards from the stock pile at a time.</p> 

 ย ย ย ย ย ย <div class="modal-buttons"> 

 ย ย ย ย ย ย ย ย <button id="draw-1-btn">Draw 1</button> 

 ย ย ย ย ย ย ย ย <button id="draw-3-btn">Draw 3</button> 

 ย ย ย ย ย ย </div> 

 ย ย ย ย </div> 

 ย ย </div> 



 ย ย <div id="card-style-modal" class="modal-overlay"> 

 ย ย ย ย <div class="modal-content"> 

 ย ย ย ย ย ย <h2>Choose Card Style</h2> 

 ย ย ย ย ย ย <p>Select your preferred card face style for this game.</p> 

 ย ย ย ย ย ย <div class="modal-buttons"> 

 ย ย ย ย ย ย ย ย <button id="normal-style-btn">Normal</button> 

 ย ย ย ย ย ย ย ย <button id="easy-see-btn">Easy See</button> 

 ย ย ย ย ย ย </div> 

 ย ย ย ย </div> 

 ย ย </div> 



 ย ย <div id="options-modal" class="modal-overlay"> 

 ย ย ย ย <div class="modal-content"> 

 ย ย ย ย ย ย <span class="close-btn">&times;</span> 

 ย ย ย ย ย ย <h2>Options</h2> 

 ย ย ย ย ย ย <div class="options-section"> 

 ย ย ย ย ย ย ย ย <h4>Playing Boards</h4> 

 ย ย ย ย ย ย ย ย <div>New backgrounds unlock with each level!</div> 

 ย ย ย ย ย ย ย ย <div id="board-selector" class="options-grid"></div> 

 ย ย ย ย ย ย </div> 

 ย ย ย ย ย ย <div class="options-section"> 

 ย ย ย ย ย ย ย ย <h4>Card Backs</h4> 

 ย ย ย ย ย ย ย ย <div>New card backs unlock with each level!</div> 

 ย ย ย ย ย ย ย ย <div id="card-back-selector" class="options-grid"></div> 

 ย ย ย ย ย ย </div> 

 ย ย ย ย ย ย ย<div class="options-section"> 

 ย ย ย ย ย ย ย ย <h4>Music Tracks</h4> 

 ย ย ย ย ย ย ย ย <div>New tracks unlock every other level!</div> 

 ย ย ย ย ย ย ย ย <div id="music-selector" class="options-grid"></div> 

 ย ย ย ย ย ย </div> 

 ย ย ย ย ย ย <div class="options-section" style="text-align: center; margin-top: 30px;"> 

 ย ย ย ย ย ย ย ย <button id="reset-progress-btn" style="background-color: #d9534f; border-color: #d43f3a;">Reset All Progress</button> 

 ย ย ย ย ย ย </div> 

 ย ย ย ย </div> 

 ย ย </div> 



 ย ย <div id="reset-confirm-modal" class="modal-overlay"> 

 ย ย ย ย <div class="modal-content"> 

 ย ย ย ย ย ย <h2>Reset Progress</h2> 

 ย ย ย ย ย ย <p>Are you sure you want to reset all of your progress? This action cannot be undone.</p> 

 ย ย ย ย ย ย <div class="modal-buttons"> 

 ย ย ย ย ย ย ย ย <button id="reset-confirm-btn">Yes, Reset</button> 

 ย ย ย ย ย ย ย ย <button id="reset-cancel-btn">Cancel</button> 

 ย ย ย ย ย ย </div> 

 ย ย ย ย </div> 

 ย ย </div> 

 ย ยย 

 ย ย <div id="unlock-modal" class="modal-overlay"> 

 ย ย ย ย <div class="modal-content"> 

 ย ย ย ย ย ย <h2 id="unlock-title"></h2> 

 ย ย ย ย ย ย <p id="unlock-description"></p> 

 ย ย ย ย ย ย <p id="unlock-prompt" style="display:none;">Would you like to apply it now?</p> 

 ย ย ย ย ย ย <div class="modal-buttons"> 

 ย ย ย ย ย ย ย ย <button id="unlock-apply-btn" style="display:none;">Yes, Apply!</button> 

 ย ย ย ย ย ย ย ย <button id="unlock-close-btn">Awesome!</button> 

 ย ย ย ย ย ย </div> 

 ย ย ย ย </div> 

 ย ย </div> 



 ย ย <div id="achievement-modal" class="modal-overlay"> 

 ย ย ย ย <div class="modal-content"> 

 ย ย ย ย ย ย <span class="close-btn">&times;</span> 

 ย ย ย ย ย ย <h2>Achievements</h2> 

 ย ย ย ย ย ย <div id="achievement-list"></div> 

 ย ย ย ย </div> 

 ย ย </div> 

 ย ยย 

 ย ย <div id="achievement-container"></div> 

 ย ย <div id="fireworks-container"></div> 



 ย ย <script> 

 ย ย document.addEventListener('DOMContentLoaded', () => { 

 ย ย ย ย // --- DOM Element Selection --- 

 ย ย ย ย // This section efficiently gathers all necessary HTML elements from the page 

 ย ย ย ย // to be used by the JavaScript game logic. 

 ย ย ย ย const gameBoard = document.getElementById('game-board'); 

 ย ย ย ย const stockPileEl = document.getElementById('stock-pile'); 

 ย ย ย ย const wastePileEl = document.getElementById('waste-pile'); 

 ย ย ย ย const foundationEls = Array.from({ length: 4 }, (_, i) => document.getElementById(`foundation-${i}`)); 

 ย ย ย ย const tableauEls = Array.from({ length: 7 }, (_, i) => document.getElementById(`tableau-${i}`)); 

 ย ย ย ย const newGameBtn = document.getElementById('new-game-btn'); 

 ย ย ย ย const autocompleteBtn = document.getElementById('autocomplete-btn'); 

 ย ย ย ย const hintBtn = document.getElementById('hint-btn'); 

 ย ย ย ย const undoBtn = document.getElementById('undo-btn'); 

 ย ย ย ย const messageBox = document.getElementById('message-box'); 

 ย ย ย ย const titleScreen = document.getElementById('title-screen'); 

 ย ย ย ย const startGameBtn = document.getElementById('start-game-btn'); 

 ย ย ย ย const gameContainer = document.getElementById('game-container'); 

 ย ย ย ย const optionsBtn = document.getElementById('options-btn'); 

 ย ย ย ย const optionsModal = document.getElementById('options-modal'); 

 ย ย ย ย const closeModalBtn = document.querySelector('#options-modal .close-btn'); 

 ย ย ย ย const unlockModal = document.getElementById('unlock-modal'); 

 ย ย ย ย const unlockCloseBtn = document.getElementById('unlock-close-btn'); 

 ย ย ย ย const unlockApplyBtn = document.getElementById('unlock-apply-btn'); 

 ย ย ย ย const unlockPrompt = document.getElementById('unlock-prompt'); 

 ย ย ย ย const unlockTitle = document.getElementById('unlock-title'); 

 ย ย ย ย const unlockDescription = document.getElementById('unlock-description'); 

 ย ย ย ย const cardBackSelector = document.getElementById('card-back-selector'); 

 ย ย ย ย const boardSelector = document.getElementById('board-selector'); 

 ย ย ย ย const musicSelector = document.getElementById('music-selector'); 

 ย ย ย ย const winCountEl = document.querySelector('#options-modal #win-count'); 

 ย ย ย ย const levelTextEl = document.getElementById('level-text'); 

 ย ย ย ย const xpTextEl = document.getElementById('xp-text'); 

 ย ย ย ย const xpBarEl = document.getElementById('xp-bar'); 

 ย ย ย ย const comboCanvas = document.getElementById('combo-canvas'); 

 ย ย ย ย const gameTimerEl = document.getElementById('game-timer'); 

 ย ย ย ย const cardBackUnlockScoreEl = document.getElementById('card-back-unlock-score'); 

 ย ย ย ย const boardUnlockScoreEl = document.getElementById('board-unlock-score'); 

 ย ย ย ย const achievementContainer = document.getElementById('achievement-container'); 

 ย ย ย ย const achievementScoreDisplay = document.getElementById('achievement-score-display'); 

 ย ย ย ย const achievementsBtn = document.getElementById('achievements-btn'); 

 ย ย ย ย const achievementModal = document.getElementById('achievement-modal'); 

 ย ย ย ย const achievementListEl = document.getElementById('achievement-list'); 

 ย ย ย ย const closeAchievementModalBtn = document.querySelector('#achievement-modal .close-btn'); 

 ย ย ย ย const flashOverlay = document.getElementById('flash-overlay'); 

 ย ย ย ย const drawSelectModal = document.getElementById('draw-select-modal'); 

 ย ย ย ย const draw1Btn = document.getElementById('draw-1-btn'); 

 ย ย ย ย const draw3Btn = document.getElementById('draw-3-btn'); 

 ย ย ย ย const cardStyleModal = document.getElementById('card-style-modal'); 

 ย ย ย ย const normalStyleBtn = document.getElementById('normal-style-btn'); 

 ย ย ย ย const easySeeBtn = document.getElementById('easy-see-btn'); 

 ย ย ย ย const fullscreenBtn = document.getElementById('fullscreen-btn'); 

 ย ย ย ย const fullscreenIcon = document.getElementById('fullscreen-icon'); 

 ย ย ย ย const exitFullscreenIcon = document.getElementById('exit-fullscreen-icon'); 

 ย ย ย ย const muteBtn = document.getElementById('mute-btn'); 

 ย ย ย ย const unmutedIcon = document.getElementById('unmuted-icon'); 

 ย ย ย ย const mutedIcon = document.getElementById('muted-icon'); 

 ย ย ย ย const resetProgressBtn = document.getElementById('reset-progress-btn'); 

 ย ย ย ย const resetConfirmModal = document.getElementById('reset-confirm-modal'); 

 ย ย ย ย const resetConfirmBtn = document.getElementById('reset-confirm-btn'); 

 ย ย ย ย const resetCancelBtn = document.getElementById('reset-cancel-btn'); 

 ย ย ย ย const starfieldCanvas = document.getElementById('starfield-canvas'); 

 ย ย ย ย const lavalampCanvas = document.getElementById('lavalamp-canvas'); 

 ย ย ย ย const oceanCanvas = document.getElementById('ocean-canvas'); 

 ย ย ย ย const matrixCanvas = document.getElementById('matrix-canvas'); 

 ย ย ย ย const geometricCanvas = document.getElementById('geometric-canvas'); 

 ย ย ย ย const fireCanvas = document.getElementById('fire-canvas'); 

 ย ย ย ย const rainCanvas = document.getElementById('rain-canvas'); 

 ย ย ย ย const hyperspaceCanvas = document.getElementById('hyperspace-canvas'); 

 ย ย ย ย const plasmaCanvas = document.getElementById('plasma-canvas'); 

 ย ย ย ย const forestCanvas = document.getElementById('forest-canvas'); 

 ย ย ย ย const neongridCanvas = document.getElementById('neongrid-canvas'); 

 ย ย ย ย const sakuraCanvas = document.getElementById('sakura-canvas'); 

 ย ย ย ย const quantumCanvas = document.getElementById('quantum-canvas'); 

 ย ย ย ย const digitalrainCanvas = document.getElementById('digitalrain-canvas'); 

 ย ย ย ย const sandsCanvas = document.getElementById('sands-canvas'); 

 ย ย ย ย const inkblotCanvas = document.getElementById('inkblot-canvas'); 

 ย ย ย ย const cosmicCanvas = document.getElementById('cosmic-canvas'); 

 ย ย ย ย const musicvizCanvas = document.getElementById('musicviz-canvas'); 

 ย ย ย ย const bioforestCanvas = document.getElementById('bioforest-canvas'); 

 ย ย ย ย const stainedglassCanvas = document.getElementById('stainedglass-canvas'); 

 ย ย ย ย const wateryCanvas = document.getElementById('watery-canvas'); 

 ย ย ย ย const swarmCanvas = document.getElementById('swarm-canvas'); 

 ย ย ย ย const glitchCanvas = document.getElementById('glitch-canvas'); 

 ย ย ย ย const auroraCanvas = document.getElementById('aurora-canvas'); 

 ย ย ย ย const constellationCanvas = document.getElementById('constellation-canvas'); 

 ย ย ย ย const synthwaveCanvas = document.getElementById('synthwave-canvas'); 

 ย ย ย ย const nebulaCanvas = document.getElementById('nebula-canvas'); 

 ย ย ย ย const jungleCanvas = document.getElementById('jungle-canvas'); 

 ย ย ย ย const cityscapeCanvas = document.getElementById('cityscape-canvas'); 

 ย ย ย ย const paintCanvas = document.getElementById('paint-canvas'); 

 ย ย ย ย const laserGridCanvas = document.getElementById('laserGrid-canvas'); 

 ย ย ย ย const neonPalmsCanvas = document.getElementById('neonPalms-canvas'); 

 ย ย ย ย const memphisCanvas = document.getElementById('memphis-canvas'); 

 ย ย ย ย const cassetteCanvas = document.getElementById('cassette-canvas'); 

 ย ย ย ย const eightBitCityCanvas = document.getElementById('eightBitCity-canvas'); 





 ย ย ย ย // --- Game Constants --- 

 ย ย ย ย // These are the fundamental rules and definitions for the game, such as suits, 

 ย ย ย ย // values, level progression, and achievement details. 

 ย ย ย ย const SUITS = ['โฅ', 'โฆ', 'โฃ', 'โ']; 

 ย ย ย ย const VALUES = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']; 

 ย ย ย ย const CARD_OVERLAP = 28; 

 ย ย ย ย const LEVEL_THRESHOLDS = (() => { 

 ย ย ย ย ย ย const thresholds = [0]; 

 ย ย ย ย ย ย for (let i = 1; i < 101; i++) { // Extended to level 100 for new unlocks 

 ย ย ย ย ย ย ย ย thresholds.push(thresholds[i-1] + (i * 10) + 10); 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย return thresholds; 

 ย ย ย ย })(); 

 ย ย ย ย const COMBO_WORDS = ["Good!", "Great!", "Excellent!", "Amazing!", "Wonderful!", "SUPER!", "INCREDIBLE!", "UNSTOPPABLE!", "GODLIKE!"]; 

 ย ย ย ย const CARD_BACKS = [ 

 ย ย ย ย ย ย ...Array.from({length: 50}, (_, i) => ({ id: `back-${i}`, name: `Style ${i+1}`, type: 'procedural' })), 

 ย ย ย ย ย ย { id: 'animated-vortex', name: 'Vortex', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'animated-scanlines', name: 'Scan Lines', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'animated-pulse', name: 'Pulse', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'animated-rainbow', name: 'Rainbow Shift', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'animated-circuitry', name: 'Circuitry', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'animated-liquid', name: 'Liquid Metal', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'animated-stars', name: 'Twinkling Stars', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'animated-ice', name: 'Glacial Ice', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'animated-runes', name: 'Arcane Runes', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'animated-molten', name: 'Molten Core', type: 'animated' } 

 ย ย ย ย ]; 



 ย ย ย ย function shuffleArray(array) { 

 ย ย ย ย ย ย for (let i = array.length - 1; i > 0; i--) { 

 ย ย ย ย ย ย ย ย const j = Math.floor(Math.random() * (i + 1)); 

 ย ย ย ย ย ย ย ย [array[i], array[j]] = [array[j], array[i]]; 

 ย ย ย ย ย ย } 

 ย ย ย ย } 



 ย ย ย ย const SHUFFLED_CARD_BACKS = (() => { 

 ย ย ย ย ย ย const defaultBack = CARD_BACKS.find(b => b.id === 'back-0'); 

 ย ย ย ย ย ย const otherBacks = CARD_BACKS.filter(b => b.id !== 'back-0'); 

 ย ย ย ย ย ย shuffleArray(otherBacks); 

 ย ย ย ย ย ย return [defaultBack, ...otherBacks]; 

 ย ย ย ย })(); 



 ย ย ย ย const BOARD_DATA = [ 

 ย ย ย ย ย ย { id: 'board-0', name: 'Classic Green', type: 'procedural' }, 

 ย ย ย ย ย ย { id: 'board-1', name: 'Lava Lamp', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-2', name: 'Starfield', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-3', name: 'Ocean Waves', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-4', name: 'Matrix', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-5', name: 'Geometric', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-6', name: 'Soothing Fire', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-7', name: 'Gentle Rain', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-8', name: 'Hyperspace', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-9', name: 'Plasma', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-10', name: 'Enchanted Forest', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-11', name: 'Neon Grid', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-12', name: 'Sakura Blizzard', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-13', name: 'Quantum Foam', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-14', name: 'Digital Rain', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-15', name: 'Shifting Sands', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-16', name: 'Ink Blot', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-17', name: 'Cosmic Ripples', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-18', name: 'Musical Visualizer', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-19', name: 'Bioluminescent Forest', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-20', name: 'Stained Glass', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-21', name: 'Watery Surface', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-22', name: 'Particle Swarm', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-23', name: 'Glitchscape', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-24', name: 'Aurora Borealis', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-25', name: 'Interactive Constellations', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-26', name: 'Synthwave Sunset', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-27', name: 'Deep Space Nebula', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-28', name: 'Jungle Canopy', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-29', name: 'Cityscape at Night', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-30', name: 'Abstract Paint', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-31', name: 'Laser Grid', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-32', name: 'Neon Palms', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-33', name: 'Memphis Pattern', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-34', name: 'Cassette Tape', type: 'animated' }, 

 ย ย ย ย ย ย { id: 'board-35', name: '8-bit City', type: 'animated' }, 

 ย ย ย ย ย ย ...Array.from({length: 24}, (_, i) => ({ id: `board-${i + 36}`, name: `Pattern ${i + 1}`, type: 'procedural' })) 

 ย ย ย ย ]; 

 ย ย ย ย const MUSIC_DATA = Array.from({length: 10}, (_, i) => ({ 

 ย ย ย ย ย ย id: `track-${i+1}`, 

 ย ย ย ย ย ย name: `Track ${String(i + 1).padStart(2, '0')}`, 

 ย ย ย ย ย ย url: `https://raw.githubusercontent.com/cdbyall/solitaire/main/music/${String(i + 1).padStart(2, '0')}.mp3` 

 ย ย ย ย })); 

 ย ย ย ย const ACHIEVEMENTS = { 

 ย ย ย ย ย ย firstMove: { name: "Getting Started", desc: "Make your first move.", xp: 1, icon: "โถ๏ธ", points: 10 }, 

 ย ย ย ย ย ย firstFoundation: { name: "On the Up and Up", desc: "Place your first card on a foundation.", xp: 5, icon: "๐", points: 10 }, 

 ย ย ย ย ย ย kingMe: { name: "All Hail the King", desc: "Place a King on an empty tableau pile.", xp: 5, icon: "๐", points: 10 }, 

 ย ย ย ย ย ย clearPile: { name: "Clean Sweep", desc: "Clear a tableau pile of all cards.", xp: 10, icon: "๐งน", points: 20 }, 

 ย ย ย ย ย ย combo5: { name: "Chain Reaction", desc: "Achieve a x5 combo.", xp: 10, icon: "๐ฅ", points: 20 }, 

 ย ย ย ย ย ย speedy: { name: "Quick Draw", desc: "Win a game in under 5 minutes.", xp: 25, icon: "โฑ๏ธ", points: 50 }, 

 ย ย ย ย ย ย win1: { name: "First Victory", desc: "Win your first game.", xp: 10, icon: "๐ฅ", points: 20 }, 

 ย ย ย ย ย ย win5: { name: "Five-Timer", desc: "Win 5 games.", xp: 20, icon: "๐๏ธ", points: 50 }, 

 ย ย ย ย ย ย win10: { name: "Decade of Dominance", desc: "Win 10 games.", xp: 50, icon: "๐", points: 100 }, 

 ย ย ย ย ย ย winStreak2: { name: "Double Down", desc: "Win 2 games in a row.", xp: 20, icon: "โ๏ธ", points: 50 }, 

 ย ย ย ย ย ย winStreak3: { name: "Triple Threat", desc: "Win 3 games in a row.", xp: 50, icon: "๐ฅ", points: 100 }, 

 ย ย ย ย ย ย newGameSpam: { name: "A Bit Impatient?", desc: "Click 'New Game' 5 times in 10 seconds.", xp: 0, icon: "๐", points: 10, secret: true }, 

 ย ย ย ย ย ย fullStack1: { name: "Column Major", desc: "Build a full stack from King to Ace.", xp: 20, icon: "๐๏ธ", points: 20 }, 

 ย ย ย ย ย ย fullStack2: { name: "Major Major", desc: "Build two full stacks in one game.", xp: 50, icon: "๐๏ธ๐๏ธ", points: 50 }, 

 ย ย ย ย ย ย firstUndo: { name: "Second Thoughts", desc: "Use the Undo button for the first time.", xp: 1, icon: "โ", points: 10 }, 

 ย ย ย ย ย ย firstHint: { name: "A Little Help?", desc: "Use the Hint button for the first time.", xp: 1, icon: "๐ก", points: 10 }, 

 ย ย ย ย ย ย level2: { name: "Rookie", desc: "Reach Level 2.", xp: 10, icon: "โญ", points: 10 }, 

 ย ย ย ย ย ย level5: { name: "Veteran", desc: "Reach Level 5.", xp: 20, icon: "โญโญ", points: 20 }, 

 ย ย ย ย ย ย level10: { name: "Solitaire Pro", desc: "Reach Level 10.", xp: 50, icon: "โญโญโญ", points: 50 }, 

 ย ย ย ย }; 



 ย ย ย ย // --- Game State Variables --- 

 ย ย ย ย // These variables track the current state of the game, including the card piles, 

 ย ย ย ย // player progress, and various settings. 

 ย ย ย ย let stock = [], waste = [], foundations = [[], [], [], []], tableau = [[], [], [], [], [], [], []]; 

 ย ย ย ย let drawCount = 3; 

 ย ย ย ย let isGameWon = false; 

 ย ย ย ย let winCount = 0; 

 ย ย ย ย let winStreak = 0; 

 ย ย ย ย let unlockedBacks = ['back-0']; 

 ย ย ย ย let selectedBack = 'back-0'; 

 ย ย ย ย let unlockedBoards = ['board-0']; 

 ย ย ย ย let selectedBoard = 'board-0'; 

 ย ย ย ย let faceStyle = 'default'; 

 ย ย ย ย let playerXP = 0; 

 ย ย ย ย let playerLevel = 1; 

 ย ย ย ย let hintsAvailable = 0; 

 ย ย ย ย let undosAvailable = 0; 

 ย ย ย ย let gameTimerInterval; 

 ย ย ย ย let gameTime = 0; 

 ย ย ย ย let lastStockClickTime = 0; 

 ย ย ย ย let moveHistory = []; 

 ย ย ย ย let unlockedAchievements = []; 

 ย ย ย ย let achievementScore = 0; 

 ย ย ย ย let newGameClickTimes = []; 

 ย ย ย ย let lastLifeLostTime = 0; 

 ย ย ย ย let devUnlockCounter = 0; // Counter for the secret unlock code 

 ย ย ย ย let isMuted = false; 

 ย ย ย ย let unlockedTracks = ['track-1']; 

 ย ย ย ย let currentTrackPlayer; 

 ย ย ย ย let currentTrackIndex = -1; 

 ย ย ย ย let shuffledPlaylist = []; 

 ย ย ย ย let introPlayer; 

 ย ย ย ยย 

 ย ย ย ย // --- Drag & Drop State --- 

 ย ย ย ย // Manages the state related to dragging and dropping cards. 

 ย ย ย ย let isDragging = false; 

 ย ย ย ย let dragProxyEl = null; 

 ย ย ย ย let draggedCardInfo = null; 

 ย ย ย ย let offsetX, offsetY; 

 ย ย ย ย let clickTimeout = null; 

 ย ย ย ย let lastClickTime = 0; 

 ย ย ย ย let mouseDownPos = null; 

 ย ย ย ยย 

 ย ย ย ย // --- Game-specific XP State --- 

 ย ย ย ย // Tracks bonuses awarded within a single game session. 

 ย ย ย ย let aceBonusAwarded = false; 

 ย ย ย ย let tableauBonusAwarded = []; 



 ย ย ย ย // --- Combo State --- 

 ย ย ย ย // Manages the combo system for consecutive moves. 

 ย ย ย ย let lastMoveTime = 0; 

 ย ย ย ย let comboCounter = 0; 

 ย ย ย ย let comboTimeout; 



 ย ย ย ย // --- Physics Engine --- 

 ย ย ย ย // Matter.js variables for handling physics-based animations. 

 ย ย ย ย let engine, matterRender, world, mouseConstraint; 

 ย ย ย ย let comboBodies = []; 

 ย ย ย ย let winAnimationTimeout; 



 ย ย ย ย // --- Animated Backgrounds --- 

 ย ย ย ย // Contexts and animation IDs for the various canvas-based backgrounds. 

 ย ย ย ย let starfieldCtx, stars = [], starfieldAnimationId = null; 

 ย ย ย ย let lavalampCtx, blobs = [], lavalampAnimationId = null; 

 ย ย ย ย let oceanCtx, waveTime = 0, oceanAnimationId = null; 

 ย ย ย ย let matrixCtx, drops = [], matrixAnimationId = null; 

 ย ย ย ย let geometricCtx, geoTime = 0, geometricAnimationId = null; 

 ย ย ย ย let fireCtx, particles = [], fireAnimationId = null; 

 ย ย ย ย let rainCtx, raindrops = [], rainAnimationId = null; 

 ย ย ย ย let hyperspaceCtx, hyperStars = [], hyperspaceAnimationId = null; 

 ย ย ย ย let plasmaCtx, plasmaTime = 0, plasmaAnimationId = null; 

 ย ย ย ย let forestCtx, leaves = [], forestAnimationId = null; 

 ย ย ย ย let neongridCtx, neongridAnimationId = null; 

 ย ย ย ย let sakuraCtx, sakuraPetals = [], sakuraAnimationId = null; 

 ย ย ย ย let quantumCtx, quantumParticles = [], quantumAnimationId = null; 

 ย ย ย ย let digitalrainCtx, digitalDrops = [], digitalrainAnimationId = null; 

 ย ย ย ย let sandsCtx, sandTime = 0, sandsAnimationId = null; 

 ย ย ย ย let inkblotCtx, inkblots = [], inkblotAnimationId = null; 

 ย ย ย ย let cosmicCtx, cosmicStars = [], cosmicRipples = [], cosmicAnimationId = null; 

 ย ย ย ย let musicvizCtx, analyser, musicvizAnimationId = null; 

 ย ย ย ย let bioforestCtx, bioPlants = [], bioforestAnimationId = null; 

 ย ย ย ย let stainedglassCtx, glassPanes = [], stainedglassAnimationId = null; 

 ย ย ย ย let wateryCtx, wateryRipples = [], wateryAnimationId = null; 

 ย ย ย ย let swarmCtx, swarmParticles = [], swarmAnimationId = null; 

 ย ย ย ย let glitchCtx, glitchData, glitchAnimationId = null; 

 ย ย ย ย let auroraCtx, auroraParticles = [], auroraAnimationId = null; 

 ย ย ย ย let constellationCtx, constellationStars = [], constellationLines = [], constellationAnimationId = null; 

 ย ย ย ย let synthwaveCtx, synthwaveTime = 0, synthwaveAnimationId = null; 

 ย ย ย ย let nebulaCtx, nebulaParticles = [], nebulaAnimationId = null; 

 ย ย ย ย let jungleCtx, jungleVines = [], jungleAnimationId = null; 

 ย ย ย ย let cityscapeCtx, cityscapeWindows = [], cityscapeAnimationId = null; 

 ย ย ย ย let paintCtx, paintBlobs = [], paintAnimationId = null; 

 ย ย ย ย let laserGridCtx, laserGridTime = 0, laserGridAnimationId = null; 

 ย ย ย ย let neonPalmsCtx, neonPalmsTime = 0, neonPalmsAnimationId = null; 

 ย ย ย ย let memphisCtx, memphisShapes = [], memphisAnimationId = null; 

 ย ย ย ย let cassetteCtx, cassetteTime = 0, cassetteAnimationId = null; 

 ย ย ย ย let eightBitCityCtx, eightBitCityBuildings = [], eightBitCityAnimationId = null; 

 ย ย ย ย let mousePos = { x: 0, y: 0 }; 

 ย ย ย ย let currentApplyCallback = null; 

 ย ย ย ย let unlockPopupQueue = []; 

 ย ย ย ย let isPopupVisible = false; 





 ย ย ย ย // --- Sound Engine --- 

 ย ย ย ย // Initializes the sound effects using Tone.js for an immersive audio experience. 

 ย ย ย ย let sounds; 

 ย ย ย ย function setupSounds() { 

 ย ย ย ย ย ย sounds = { 

 ย ย ย ย ย ย ย ย place: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 } }).toDestination(), 

 ย ย ย ย ย ย ย ย foundationPlace: new Tone.PolySynth(Tone.MetalSynth, { frequency: 200, envelope: { attack: 0.001, decay: 0.4, release: 0.2 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination(), 

 ย ย ย ย ย ย ย ย error: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0 } }).toDestination(), 

 ย ย ย ย ย ย ย ย win: new Tone.PolySynth(Tone.Synth).toDestination(), 

 ย ย ย ย ย ย ย ย click: new Tone.PolySynth(Tone.MembraneSynth).toDestination(), 

 ย ย ย ย ย ย ย ย levelUp: new Tone.Synth().toDestination(), 

 ย ย ย ย ย ย ย ย achievement: new Tone.PluckSynth({ attackNoise: 0.5, dampening: 4000, resonance: 0.9 }).toDestination(), 

 ย ย ย ย ย ย ย ย combo: new Tone.PolySynth(Tone.FMSynth, { harmonicity: 3, modulationIndex: 10, detune: 0, oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.5, release: 0.5 }, modulation: { type: "square" }, modulationEnvelope: { attack: 0.01, decay: 0.2, sustain: 0.5, release: 0.5 } }).toDestination(), 

 ย ย ย ย ย ย ย ย pop: new Tone.PolySynth(Tone.MembraneSynth, { pitchDecay: 0.01, octaves: 2, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.01 } }).toDestination(), 

 ย ย ย ย ย ย }; 

 ย ย ย ย ย ย // Create an analyser node to get frequency data for the visualizer 

 ย ย ย ย ย ย analyser = new Tone.Analyser('fft', 32); 

 ย ย ย ย ย ย Tone.getDestination().connect(analyser); 

 ย ย ย ย } 

 ย ย ย ยย 

 ย ย ย ย // --- Game Initialization --- 

 ย ย ย ย /** 

 ย ย ย ย ย* Creates the animated card fan effect on the title screen. 

 ย ย ย ย ย*/ 

 ย ย ย ย function animateTitleScreen() { 

 ย ย ย ย ย ย const container = document.querySelector('.title-cards'); 

 ย ย ย ย ย ย container.innerHTML = ''; 

 ย ย ย ย ย ย const titleSuits = ['โฅ', 'โฆ', 'โฃ', 'โ', 'โ']; 

 ย ย ย ย ย ย for (let i = 0; i < 5; i++) { 

 ย ย ย ย ย ย ย ย const card = document.createElement('div'); 

 ย ย ย ย ย ย ย ย card.className = 'title-card'; 

 ย ย ย ย ย ย ย ย card.style.setProperty('--rot', `${(i - 2) * 15}deg`); 

 ย ย ย ย ย ย ย ย card.style.setProperty('--i', i); 

 ย ย ย ย ย ย ย ยย 

 ย ย ย ย ย ย ย ย const cardInner = document.createElement('div'); 

 ย ย ย ย ย ย ย ย cardInner.className = 'title-card-inner'; 



 ย ย ย ย ย ย ย ย const cardFront = document.createElement('div'); 

 ย ย ย ย ย ย ย ย cardFront.className = 'title-card-front'; 

 ย ย ย ย ย ย ย ย cardFront.textContent = titleSuits[i]; 

 ย ย ย ย ย ย ย ย cardFront.style.color = (i < 2) ? '#d90429' : '#000000'; 



 ย ย ย ย ย ย ย ย const cardBack = document.createElement('div'); 

 ย ย ย ย ย ย ย ย cardBack.className = 'title-card-back'; 



 ย ย ย ย ย ย ย ย cardInner.appendChild(cardFront); 

 ย ย ย ย ย ย ย ย cardInner.appendChild(cardBack); 

 ย ย ย ย ย ย ย ย card.appendChild(cardInner); 

 ย ย ย ย ย ย ย ย container.appendChild(card); 

 ย ย ย ย ย ย } 

 ย ย ย ย } 



 ย ย ย ย /** 

 ย ย ย ย ย* Sets up the Matter.js physics engine for combo text animations. 

 ย ย ย ย ย*/ 

 ย ย ย ย function setupPhysics() { 

 ย ย ย ย ย ย const { Engine, Render, World, Bodies, Mouse, MouseConstraint, Runner, Events } = Matter; 

 ย ย ย ย ย ย engine = Engine.create({ gravity: { y: 0.2 } }); 

 ย ย ย ย ย ย world = engine.world; 

 ย ย ย ย ย ย matterRender = Render.create({ 

 ย ย ย ย ย ย ย ย canvas: comboCanvas, 

 ย ย ย ย ย ย ย ย engine: engine, 

 ย ย ย ย ย ย ย ย options: { 

 ย ย ย ย ย ย ย ย ย ย width: window.innerWidth, 

 ย ย ย ย ย ย ย ย ย ย height: window.innerHeight, 

 ย ย ย ย ย ย ย ย ย ย wireframes: false, 

 ย ย ย ย ย ย ย ย ย ย background: 'transparent' 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย }); 



 ย ย ย ย ย ย const mouse = Mouse.create(matterRender.canvas); 

 ย ย ย ย ย ย mouseConstraint = MouseConstraint.create(engine, { 

 ย ย ย ย ย ย ย ย mouse: mouse, 

 ย ย ย ย ย ย ย ย constraint: { 

 ย ย ย ย ย ย ย ย ย ย stiffness: 0.2, 

 ย ย ย ย ย ย ย ย ย ย render: { visible: false } 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย }); 

 ย ย ย ย ย ย World.add(world, mouseConstraint); 

 ย ย ย ย ย ย matterRender.mouse = mouse; 



 ย ย ย ย ย ย Runner.run(engine); 

 ย ย ย ย ย ย Render.run(matterRender); 



 ย ย ย ย ย ย // Allow user to pop the combo text bodies by clicking them 

 ย ย ย ย ย ย Events.on(mouseConstraint, 'mousedown', function(event) { 

 ย ย ย ย ย ย ย ย const clickedBody = Matter.Query.point(comboBodies, event.mouse.position)[0]; 

 ย ย ย ย ย ย ย ย if (clickedBody) { 

 ย ย ย ย ย ย ย ย ย ย sounds.pop.triggerAttackRelease("C3", "8n"); 

 ย ย ย ย ย ย ย ย ย ย Matter.World.remove(world, clickedBody); 

 ย ย ย ย ย ย ย ย ย ย comboBodies = comboBodies.filter(b => b !== clickedBody); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย }); 

 ย ย ย ย } 



 ย ย ย ย function initializeAudio() { 

 ย ย ย ย ย ย Tone.start().then(() => { 

 ย ย ย ย ย ย ย ย setupSounds(); 

 ย ย ย ย ย ย ย ย setupPhysics(); 



 ย ย ย ย ย ย ย ย if (!titleScreen.classList.contains('hidden')) { 

 ย ย ย ย ย ย ย ย ย ย introPlayer = new Tone.Player("https://raw.githubusercontent.com/cdbyall/solitaire/main/music/00.mp3").toDestination(); 

 ย ย ย ย ย ย ย ย ย ย introPlayer.loop = true; 

 ย ย ย ย ย ย ย ย ย ย introPlayer.autostart = true; 

 ย ย ย ย ย ย ย ย ย ย updateMuteState(false); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย }); 

 ย ย ย ย ย ย document.removeEventListener('click', initializeAudio); 

 ย ย ย ย ย ย document.removeEventListener('touchstart', initializeAudio); 

 ย ย ย ย } 

 ย ย ย ย document.addEventListener('click', initializeAudio, { once: true }); 

 ย ย ย ย document.addEventListener('touchstart', initializeAudio, { once: true }); 



 ย ย ย ย startGameBtn.addEventListener('click', () => { 

 ย ย ย ย ย ย if (sounds && sounds.click) sounds.click.triggerAttackRelease("C2", "8n"); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย titleScreen.classList.add('hidden'); 

 ย ย ย ย ย ย setTimeout(() => { 

 ย ย ย ย ย ย ย ย gameContainer.style.display = 'flex'; 

 ย ย ย ย ย ย ย ย loadProgress(); 

 ย ย ย ย ย ย ย ย promptNewGame(); 

 ย ย ย ย ย ย }, 500); 

 ย ย ย ย }); 



 ย ย ย ย /** 

 ย ย ย ย ย* Shows the initial modals to select game options. 

 ย ย ย ย ย*/ 

 ย ย ย ย function promptNewGame() { 

 ย ย ย ย ย ย drawSelectModal.style.display = 'flex'; 

 ย ย ย ย } 



 ย ย ย ย /** 

 ย ย ย ย ย* Resets the game state and deals a new set of cards. 

 ย ย ย ย ย*/ 

 ย ย ย ย function initializeNewGame() { 

 ย ย ย ย ย ย if (introPlayer) { 

 ย ย ย ย ย ย ย ย introPlayer.stop(); 

 ย ย ย ย ย ย ย ย introPlayer.dispose(); 

 ย ย ย ย ย ย ย ย introPlayer = null; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย


 ย ย ย ย ย ย if (!isGameWon) { 

 ย ย ย ย ย ย ย ย winStreak = 0; // Reset streak if the previous game wasn't won 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย isGameWon = false; 

 ย ย ย ย ย ย aceBonusAwarded = false; 

 ย ย ย ย ย ย tableauBonusAwarded = [false, false, false, false, false, false, false]; 

 ย ย ย ย ย ย resetCombo(); 

 ย ย ย ย ย ย startTimer(); 

 ย ย ย ย ย ย clearTimeout(winAnimationTimeout); 

 ย ย ย ย ย ย comboCanvas.style.pointerEvents = 'none'; 

 ย ย ย ย ย ย moveHistory = []; 

 ย ย ย ย ย ย gameTimerEl.textContent = '00:00'; 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย // Secret achievement check for spamming "New Game" 

 ย ย ย ย ย ย newGameClickTimes.push(Date.now()); 

 ย ย ย ย ย ย if (newGameClickTimes.length > 5) { 

 ย ย ย ย ย ย ย ย newGameClickTimes.shift(); 

 ย ย ย ย ย ย ย ย if (newGameClickTimes[4] - newGameClickTimes[0] < 10000) { 

 ย ย ย ย ย ย ย ย ย ย triggerAchievement('newGameSpam'); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย // Reset all card piles 

 ย ย ย ย ย ย stock = []; waste = []; foundations = [[], [], [], []]; 

 ย ย ย ย ย ย tableau = Array.from({ length: 7 }, () => []); 

 ย ย ย ย ย ย messageBox.textContent = ''; 

 ย ย ย ย ย ย autocompleteBtn.classList.add('hidden'); 

 ย ย ย ย ย ย gameBoard.style.pointerEvents = 'auto'; 

 ย ย ย ย ย ย document.querySelectorAll('.win-animate, .hint-glow').forEach(el => el.classList.remove('win-animate', 'hint-glow')); 



 ย ย ย ย ย ย // Create, shuffle, and deal the deck 

 ย ย ย ย ย ย const deck = createDeck(); 

 ย ย ย ย ย ย shuffleDeck(deck); 

 ย ย ย ย ย ย dealCards(deck); 

 ย ย ย ย ย ย updateCardStyles(); 

 ย ย ย ย ย ย render(); 

 ย ย ย ย ย ย updatePlayerStatsUI(); 

 ย ย ย ย } 



 ย ย ย ย // --- Data Persistence --- 

 ย ย ย ย /** 

 ย ย ย ย ย* Loads player progress from localStorage. 

 ย ย ย ย ย*/ 

 ย ย ย ย function loadProgress() { 

 ย ย ย ย ย ย winCount = parseInt(localStorage.getItem('solitaireWinCount') || '0'); 

 ย ย ย ย ย ย winStreak = parseInt(localStorage.getItem('solitaireWinStreak') || '0'); 

 ย ย ย ย ย ย unlockedBacks = JSON.parse(localStorage.getItem('solitaireUnlockedBacks') || '["back-0"]'); 

 ย ย ย ย ย ย selectedBack = localStorage.getItem('solitaireSelectedBack') || 'back-0'; 

 ย ย ย ย ย ย unlockedBoards = JSON.parse(localStorage.getItem('solitaireUnlockedBoards') || '["board-0"]'); 

 ย ย ย ย ย ย selectedBoard = localStorage.getItem('solitaireSelectedBoard') || 'board-0'; 

 ย ย ย ย ย ย playerXP = parseInt(localStorage.getItem('solitairePlayerXP') || '0'); 

 ย ย ย ย ย ย hintsAvailable = parseInt(localStorage.getItem('solitaireHintsAvailable') || '0'); 

 ย ย ย ย ย ย undosAvailable = parseInt(localStorage.getItem('solitaireUndosAvailable') || '0'); 

 ย ย ย ย ย ย unlockedAchievements = JSON.parse(localStorage.getItem('solitaireAchievements') || '[]'); 

 ย ย ย ย ย ย achievementScore = parseInt(localStorage.getItem('solitaireAchievementScore') || '0'); 

 ย ย ย ย ย ย isMuted = JSON.parse(localStorage.getItem('solitaireIsMuted') || 'false'); 

 ย ย ย ย ย ย unlockedTracks = JSON.parse(localStorage.getItem('solitaireUnlockedTracks')) || ['track-1']; 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย checkLevelUp(false); // Update level based on loaded XP 

 ย ย ย ย ย ย updateMuteState(false); // Update mute state without playing sound 

 ย ย ย ย ย ย updateCardStyles(); 

 ย ย ย ย ย ย updatePlayerStatsUI(); 

 ย ย ย ย } 



 ย ย ย ย /** 

 ย ย ย ย ย* Saves player progress to localStorage. 

 ย ย ย ย ย*/ 

 ย ย ย ย function saveProgress() { 

 ย ย ย ย ย ย localStorage.setItem('solitaireWinCount', winCount); 

 ย ย ย ย ย ย localStorage.setItem('solitaireWinStreak', winStreak); 

 ย ย ย ย ย ย localStorage.setItem('solitaireUnlockedBacks', JSON.stringify(unlockedBacks)); 

 ย ย ย ย ย ย localStorage.setItem('solitaireSelectedBack', selectedBack); 

 ย ย ย ย ย ย localStorage.setItem('solitaireUnlockedBoards', JSON.stringify(unlockedBoards)); 

 ย ย ย ย ย ย localStorage.setItem('solitaireSelectedBoard', selectedBoard); 

 ย ย ย ย ย ย localStorage.setItem('solitairePlayerXP', playerXP); 

 ย ย ย ย ย ย localStorage.setItem('solitaireHintsAvailable', hintsAvailable); 

 ย ย ย ย ย ย localStorage.setItem('solitaireUndosAvailable', undosAvailable); 

 ย ย ย ย ย ย localStorage.setItem('solitaireAchievements', JSON.stringify(unlockedAchievements)); 

 ย ย ย ย ย ย localStorage.setItem('solitaireAchievementScore', achievementScore); 

 ย ย ย ย ย ย localStorage.setItem('solitaireIsMuted', JSON.stringify(isMuted)); 

 ย ย ย ย ย ย localStorage.setItem('solitaireUnlockedTracks', JSON.stringify(unlockedTracks)); 

 ย ย ย ย } 



 ย ย ย ย // --- Animated Backgrounds --- 

 ย ย ย ย // Each background has setup, animate, start, and stop functions. 

 ย ย ย ย // They manage their own canvas, animation loop, and state. 

 ย ย ย ยย 

 ย ย ย ย function setupStarfield() { if (!starfieldCanvas) return; starfieldCanvas.width = window.innerWidth; starfieldCanvas.height = window.innerHeight; starfieldCtx = starfieldCanvas.getContext('2d'); stars = []; const numStars = window.innerWidth < 600 ? 400 : 800; const w = starfieldCanvas.width; const h = starfieldCanvas.height; for(let i = 0; i < numStars; i++) { stars.push({ x: Math.random() * w - w / 2, y: Math.random() * h - h / 2, z: Math.random() * w }); } } 

 ย ย ย ย function animateStarfield() { if (!starfieldCtx) return; const w = starfieldCanvas.width; const h = starfieldCanvas.height; const speed = 2; starfieldCtx.fillStyle = 'rgba(0, 0, 0, 0.2)'; starfieldCtx.fillRect(0, 0, w, h); starfieldCtx.fillStyle = 'white'; stars.forEach(star => { star.z -= speed; if (star.z <= 0) { star.x = Math.random() * w - w / 2; star.y = Math.random() * h / 2; star.z = w; } const k = 128.0 / star.z; const px = star.x * k + w / 2; const py = star.y * k + h / 2; if (px >= 0 && px < w && py >= 0 && py < h) { const size = (1 - star.z / w) * 5; starfieldCtx.fillRect(px, py, size, size); } }); starfieldAnimationId = requestAnimationFrame(animateStarfield); } 

 ย ย ย ย function startStarfield() { if (starfieldAnimationId) return; if (!starfieldCanvas) return; starfieldCanvas.style.display = 'block'; setupStarfield(); animateStarfield(); } 

 ย ย ย ย function stopStarfield() { if (!starfieldAnimationId) return; cancelAnimationFrame(starfieldAnimationId); starfieldAnimationId = null; if (starfieldCanvas) starfieldCanvas.style.display = 'none'; } 

 ย ย ย ย class Blob { constructor(w, h) { this.w = w; this.h = h; this.x = Math.random() * w; this.y = Math.random() * h; this.vx = (Math.random() - 0.5) * 2; this.vy = (Math.random() - 0.5) * 2; this.radius = Math.random() * 40 + 40; } update() { this.x += this.vx; this.y += this.vy; if (this.x < this.radius || this.x > this.w - this.radius) this.vx *= -1; if (this.y < this.radius || this.y > this.h - this.radius) this.vy *= -1; } } 

 ย ย ย ย function setupLavalamp() { if (!lavalampCanvas) return; lavalampCanvas.width = window.innerWidth; lavalampCanvas.height = window.innerHeight; lavalampCtx = lavalampCanvas.getContext('2d'); blobs = []; const numBlobs = 10; for(let i=0; i<numBlobs; i++) { blobs.push(new Blob(lavalampCanvas.width, lavalampCanvas.height)); } } 

 ย ย ย ย function animateLavalamp() { if (!lavalampCtx) return; lavalampCtx.clearRect(0, 0, lavalampCanvas.width, lavalampCanvas.height); const bgGradient = lavalampCtx.createLinearGradient(0, 0, 0, lavalampCanvas.height); bgGradient.addColorStop(0, "#3a1c71"); bgGradient.addColorStop(0.5, "#d76d77"); bgGradient.addColorStop(1, "#ffaf7b"); lavalampCtx.fillStyle = bgGradient; lavalampCtx.fillRect(0, 0, lavalampCanvas.width, lavalampCanvas.height); lavalampCtx.filter = 'blur(40px) contrast(30)'; lavalampCtx.beginPath(); blobs.forEach(blob => { blob.update(); lavalampCtx.moveTo(blob.x, blob.y); lavalampCtx.arc(blob.x, blob.y, blob.radius, 0, Math.PI * 2); }); lavalampCtx.fillStyle = 'white'; lavalampCtx.fill(); lavalampCtx.filter = 'none'; lavalampAnimationId = requestAnimationFrame(animateLavalamp); } 

 ย ย ย ย function startLavalamp() { if (lavalampAnimationId) return; if (!lavalampCanvas) return; lavalampCanvas.style.display = 'block'; setupLavalamp(); animateLavalamp(); } 

 ย ย ย ย function stopLavalamp() { if (!lavalampAnimationId) return; cancelAnimationFrame(lavalampAnimationId); lavalampAnimationId = null; if (lavalampCanvas) lavalampCanvas.style.display = 'none'; } 

 ย ย ย ย function setupOcean() { if (!oceanCanvas) return; oceanCanvas.width = window.innerWidth; oceanCanvas.height = window.innerHeight; oceanCtx = oceanCanvas.getContext('2d'); waveTime = 0; } 

 ย ย ย ย function animateOcean() { if (!oceanCtx) return; const w = oceanCanvas.width; const h = oceanCanvas.height; oceanCtx.fillStyle = '#001f3f'; oceanCtx.fillRect(0, 0, w, h); waveTime += 0.02; const drawWave = (color, alpha, speed, amplitude, frequency) => { oceanCtx.fillStyle = color; oceanCtx.globalAlpha = alpha; oceanCtx.beginPath(); oceanCtx.moveTo(0, h); for (let x = 0; x < w; x++) { const y = Math.sin(x * frequency + waveTime * speed) * amplitude + h * 0.7; oceanCtx.lineTo(x, y); } oceanCtx.lineTo(w, h); oceanCtx.fill(); }; drawWave('#7FDBFF', 0.5, 0.8, 40, 0.01); drawWave('#0074D9', 0.5, 1, 50, 0.008); drawWave('#001f3f', 0.5, 1.2, 60, 0.006); oceanCtx.globalAlpha = 1; oceanAnimationId = requestAnimationFrame(animateOcean); } 

 ย ย ย ย function startOcean() { if (oceanAnimationId) return; if (!oceanCanvas) return; oceanCanvas.style.display = 'block'; setupOcean(); animateOcean(); } 

 ย ย ย ย function stopOcean() { if (!oceanAnimationId) return; cancelAnimationFrame(oceanAnimationId); oceanAnimationId = null; if (oceanCanvas) oceanCanvas.style.display = 'none'; } 

 ย ย ย ย function setupMatrix() { if (!matrixCanvas) return; matrixCanvas.width = window.innerWidth; matrixCanvas.height = window.innerHeight; matrixCtx = matrixCanvas.getContext('2d'); const columns = matrixCanvas.width / 20; drops = []; for (let x = 0; x < columns; x++) { drops[x] = 1; } } 

 ย ย ย ย function animateMatrix() { if (!matrixCtx) return; matrixCtx.fillStyle = 'rgba(0, 0, 0, 0.05)'; matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height); matrixCtx.fillStyle = '#0F0'; matrixCtx.font = '15px monospace'; const katakana = 'ใขใกใซใตใฟใใใใคใฃใฉใฏใฌใถใใใใคใฃใญใทใใใใใชใฐใฎใธใใใใฆใฅใฏในใใใใใฆใฅใซใฐใบใใใใจใงใฑใปใใใใกใฌใฑใฒใผใใใใชใฉใณใฝใใใใขใจใงใญใฒใดใพใใใใดใใณ'; for (let i = 0; i < drops.length; i++) { const text = katakana.charAt(Math.floor(Math.random() * katakana.length)); matrixCtx.fillText(text, i * 20, drops[i] * 20); if (drops[i] * 20 > matrixCanvas.height && Math.random() > 0.975) { drops[i] = 0; } drops[i]++; } matrixAnimationId = requestAnimationFrame(animateMatrix); } 

 ย ย ย ย function startMatrix() { if (matrixAnimationId) return; if (!matrixCanvas) return; matrixCanvas.style.display = 'block'; setupMatrix(); animateMatrix(); } 

 ย ย ย ย function stopMatrix() { if (!matrixAnimationId) return; cancelAnimationFrame(matrixAnimationId); matrixAnimationId = null; if (matrixCanvas) matrixCanvas.style.display = 'none'; } 

 ย ย ย ย function setupGeometric() { if (!geometricCanvas) return; geometricCanvas.width = window.innerWidth; geometricCanvas.height = window.innerHeight; geometricCtx = geometricCanvas.getContext('2d'); geoTime = 0; } 

 ย ย ย ย function animateGeometric() { if (!geometricCtx) return; const w = geometricCanvas.width; const h = geometricCanvas.height; geometricCtx.fillStyle = 'rgba(20, 20, 30, 0.1)'; geometricCtx.fillRect(0, 0, w, h); geoTime += 0.01; geometricCtx.save(); geometricCtx.translate(w/2, h/2); for (let i = 1; i < 60; i++) { geometricCtx.strokeStyle = `hsla(${i * 10 + geoTime * 100}, 80%, 60%, ${1 - i/60})`; geometricCtx.lineWidth = 2; geometricCtx.beginPath(); const radius = i * 20; const sides = 6; geometricCtx.moveTo(radius, 0); for (let j = 1; j <= sides; j++) { const angle = (j * 2 * Math.PI / sides) + geoTime * (i % 2 === 0 ? 1 : -1); geometricCtx.lineTo(radius * Math.cos(angle), radius * Math.sin(angle)); } geometricCtx.closePath(); geometricCtx.stroke(); } geometricCtx.restore(); geometricAnimationId = requestAnimationFrame(animateGeometric); } 

 ย ย ย ย function startGeometric() { if (geometricAnimationId) return; if (!geometricCanvas) return; geometricCanvas.style.display = 'block'; setupGeometric(); animateGeometric(); } 

 ย ย ย ย function stopGeometric() { if (!geometricAnimationId) return; cancelAnimationFrame(geometricAnimationId); geometricAnimationId = null; if (geometricCanvas) geometricCanvas.style.display = 'none'; } 

 ย ย ย ย function setupFire() { if (!fireCanvas) return; fireCanvas.width = window.innerWidth; fireCanvas.height = window.innerHeight; fireCtx = fireCanvas.getContext('2d'); particles = []; for (let i = 0; i < 100; i++) { particles.push({ x: Math.random() * fireCanvas.width, y: fireCanvas.height, size: Math.random() * 5 + 1, speedY: Math.random() * 3 + 1, color: `hsl(${Math.random() * 30 + 30}, 100%, 50%)` }); } } 

 ย ย ย ย function animateFire() { if (!fireCtx) return; fireCtx.globalCompositeOperation = 'source-over'; fireCtx.fillStyle = 'rgba(0,0,0,0.1)'; fireCtx.fillRect(0, 0, fireCanvas.width, fireCanvas.height); fireCtx.globalCompositeOperation = 'lighter'; particles.forEach(p => { p.y -= p.speedY; p.x += (Math.random() - 0.5); if (p.y < 0) { p.x = Math.random() * fireCanvas.width; p.y = fireCanvas.height; } fireCtx.beginPath(); fireCtx.fillStyle = p.color; fireCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2); fireCtx.fill(); }); fireAnimationId = requestAnimationFrame(animateFire); } 

 ย ย ย ย function startFire() { if (fireAnimationId) return; if (!fireCanvas) return; fireCanvas.style.display = 'block'; setupFire(); animateFire(); } 

 ย ย ย ย function stopFire() { if (!fireAnimationId) return; cancelAnimationFrame(fireAnimationId); fireAnimationId = null; if (fireCanvas) fireCanvas.style.display = 'none'; } 

 ย ย ย ย function setupRain() { if (!rainCanvas) return; rainCanvas.width = window.innerWidth; rainCanvas.height = window.innerHeight; rainCtx = rainCanvas.getContext('2d'); raindrops = []; for (let i = 0; i < 500; i++) { raindrops.push({ x: Math.random() * rainCanvas.width, y: Math.random() * rainCanvas.height, length: Math.random() * 20 + 10, speed: Math.random() * 5 + 2 }); } } 

 ย ย ย ย function animateRain() { if (!rainCtx) return; rainCtx.fillStyle = 'rgba(0, 20, 40, 0.2)'; rainCtx.fillRect(0, 0, rainCanvas.width, rainCanvas.height); rainCtx.strokeStyle = 'rgba(174,194,224,0.5)'; rainCtx.lineWidth = 1; raindrops.forEach(drop => { drop.y += drop.speed; if (drop.y > rainCanvas.height) { drop.y = 0 - drop.length; drop.x = Math.random() * rainCanvas.width; } rainCtx.beginPath(); rainCtx.moveTo(drop.x, drop.y); rainCtx.lineTo(drop.x, drop.y + drop.length); rainCtx.stroke(); }); rainAnimationId = requestAnimationFrame(animateRain); } 

 ย ย ย ย function startRain() { if (rainAnimationId) return; if (!rainCanvas) return; rainCanvas.style.display = 'block'; setupRain(); animateRain(); } 

 ย ย ย ย function stopRain() { if (!rainAnimationId) return; cancelAnimationFrame(rainAnimationId); rainAnimationId = null; if (rainCanvas) rainCanvas.style.display = 'none'; } 

 ย ย ย ย function setupHyperspace() { if (!hyperspaceCanvas) return; hyperspaceCanvas.width = window.innerWidth; hyperspaceCanvas.height = window.innerHeight; hyperspaceCtx = hyperspaceCanvas.getContext('2d'); hyperStars = []; for (let i = 0; i < 500; i++) { hyperStars.push({ x: Math.random() * hyperspaceCanvas.width, y: Math.random() * hyperspaceCanvas.height, z: Math.random() * hyperspaceCanvas.width }); } } 

 ย ย ย ย function animateHyperspace() { if (!hyperspaceCtx) return; const w = hyperspaceCanvas.width; const h = hyperspaceCanvas.height; const halfW = w / 2; const halfH = h / 2; hyperspaceCtx.fillStyle = 'rgba(0, 0, 0, 0.2)'; hyperspaceCtx.fillRect(0, 0, w, h); hyperStars.forEach(star => { star.z -= 4; if (star.z <= 0) { star.z = w; } const k = 128.0 / star.z; const px = (star.x - halfW) * k + halfW; const py = (star.y - halfH) * k + halfH; if (px >= 0 && px < w && py >= 0 && py < h) { const size = (1 - star.z / w) * 5; const shade = (1 - star.z / w) * 255; hyperspaceCtx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`; hyperspaceCtx.fillRect(px, py, size, size); } }); hyperspaceAnimationId = requestAnimationFrame(animateHyperspace); } 

 ย ย ย ย function startHyperspace() { if (hyperspaceAnimationId) return; if (!hyperspaceCanvas) return; hyperspaceCanvas.style.display = 'block'; setupHyperspace(); animateHyperspace(); } 

 ย ย ย ย function stopHyperspace() { if (!hyperspaceAnimationId) return; cancelAnimationFrame(hyperspaceAnimationId); hyperspaceAnimationId = null; if (hyperspaceCanvas) hyperspaceCanvas.style.display = 'none'; } 

 ย ย ย ย function setupPlasma() { if (!plasmaCanvas) return; plasmaCanvas.width = 128; plasmaCanvas.height = 128; plasmaCtx = plasmaCanvas.getContext('2d'); plasmaTime = 0; } 

 ย ย ย ย function animatePlasma() { if (!plasmaCtx) return; const w = plasmaCanvas.width; const h = plasmaCanvas.height; const imgData = plasmaCtx.createImageData(w, h); const data = imgData.data; plasmaTime += 0.05; for (let x = 0; x < w; x++) { for (let y = 0; y < h; y++) { const i = (x + y * w) * 4; const v = Math.sin(x / 8 + plasmaTime) + Math.sin(y / 4 + plasmaTime) + Math.sin((x + y) / 8 + plasmaTime) + Math.sin(Math.sqrt(x * x + y * y) / 4 + plasmaTime); data[i] = Math.sin(v * Math.PI) * 128 + 127; data[i+1] = Math.sin(v * Math.PI + 2 * Math.PI / 3) * 128 + 127; data[i+2] = Math.sin(v * Math.PI + 4 * Math.PI / 3) * 128 + 127; data[i+3] = 255; } } plasmaCtx.putImageData(imgData, 0, 0); plasmaAnimationId = requestAnimationFrame(animatePlasma); } 

 ย ย ย ย function startPlasma() { if (plasmaAnimationId) return; if (!plasmaCanvas) return; plasmaCanvas.style.display = 'block'; setupPlasma(); animatePlasma(); } 

 ย ย ย ย function stopPlasma() { if (!plasmaAnimationId) return; cancelAnimationFrame(plasmaAnimationId); plasmaAnimationId = null; if (plasmaCanvas) plasmaCanvas.style.display = 'none'; } 

 ย ย ย ย function setupForest() { if (!forestCanvas) return; forestCanvas.width = window.innerWidth; forestCanvas.height = window.innerHeight; forestCtx = forestCanvas.getContext('2d'); leaves = []; for (let i = 0; i < 50; i++) { leaves.push({ x: Math.random() * forestCanvas.width, y: Math.random() * forestCanvas.height, size: Math.random() * 5 + 3, speed: Math.random() + 0.5, angle: Math.random() * Math.PI * 2 }); } } 

 ย ย ย ย function animateForest() { if (!forestCtx) return; const w = forestCanvas.width; const h = forestCanvas.height; const gradient = forestCtx.createLinearGradient(0, 0, 0, h); gradient.addColorStop(0, '#2a4a2a'); gradient.addColorStop(1, '#0a1a0a'); forestCtx.fillStyle = gradient; forestCtx.fillRect(0, 0, w, h); leaves.forEach(leaf => { leaf.y += leaf.speed; leaf.x += Math.sin(leaf.angle + leaf.y / 20); if (leaf.y > h) { leaf.y = -leaf.size; leaf.x = Math.random() * w; } forestCtx.fillStyle = 'rgba(255, 223, 186, 0.7)'; forestCtx.beginPath(); forestCtx.arc(leaf.x, leaf.y, leaf.size, 0, Math.PI * 2); forestCtx.fill(); }); forestAnimationId = requestAnimationFrame(animateForest); } 

 ย ย ย ย function startForest() { if (forestAnimationId) return; if (!forestCanvas) return; forestCanvas.style.display = 'block'; setupForest(); animateForest(); } 

 ย ย ย ย function stopForest() { if (!forestAnimationId) return; cancelAnimationFrame(forestAnimationId); forestAnimationId = null; if (forestCanvas) forestCanvas.style.display = 'none'; } 

 ย ย ย ย function setupNeonGrid() { if (!neongridCanvas) return; neongridCanvas.width = window.innerWidth; neongridCanvas.height = window.innerHeight; neongridCtx = neongridCanvas.getContext('2d'); } 

 ย ย ย ย function animateNeonGrid() { if (!neongridCtx) return; const w = neongridCanvas.width; const h = neongridCanvas.height; const time = Date.now() * 0.0002; neongridCtx.fillStyle = '#000'; neongridCtx.fillRect(0, 0, w, h); const gridSize = 50; for (let i = 0; i < w / gridSize + 1; i++) { for (let j = 0; j < h / gridSize + 1; j++) { const x = i * gridSize; const y = j * gridSize; const dx = x - w / 2; const dy = y - h / 2; const dist = Math.sqrt(dx * dx + dy * dy); const pulse = Math.sin(dist * 0.05 - time * 5) * 0.5 + 0.5; neongridCtx.strokeStyle = `rgba(0, 255, 255, ${0.2 + pulse * 0.5})`; neongridCtx.lineWidth = 1 + pulse; neongridCtx.strokeRect(x - 1, y - 1, 2, 2); } } neongridAnimationId = requestAnimationFrame(animateNeonGrid); } 

 ย ย ย ย function startNeonGrid() { if (neongridAnimationId) return; if (!neongridCanvas) return; neongridCanvas.style.display = 'block'; setupNeonGrid(); animateNeonGrid(); } 

 ย ย ย ย function stopNeonGrid() { if (!neongridAnimationId) return; cancelAnimationFrame(neongridAnimationId); neongridAnimationId = null; if (neongridCanvas) neongridCanvas.style.display = 'none'; } 

 ย ย ย ย function setupSakura() { if (!sakuraCanvas) return; sakuraCanvas.width = window.innerWidth; sakuraCanvas.height = window.innerHeight; sakuraCtx = sakuraCanvas.getContext('2d'); sakuraPetals = []; for (let i = 0; i < 50; i++) { sakuraPetals.push({ x: Math.random() * sakuraCanvas.width, y: Math.random() * sakuraCanvas.height, size: Math.random() * 3 + 2, speed: Math.random() * 1 + 0.5, angle: Math.random() * 360 }); } } 

 ย ย ย ย function animateSakura() { if (!sakuraCtx) return; const w = sakuraCanvas.width; const h = sakuraCanvas.height; sakuraCtx.fillStyle = 'rgba(255, 230, 240, 0.1)'; sakuraCtx.fillRect(0, 0, w, h); sakuraCtx.fillStyle = '#FFC0CB'; sakuraPetals.forEach(p => { p.y += p.speed; p.x += Math.sin(p.angle); p.angle += 0.01; if (p.y > h) { p.y = -p.size; p.x = Math.random() * w; } sakuraCtx.save(); sakuraCtx.translate(p.x, p.y); sakuraCtx.rotate(p.angle); sakuraCtx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size); sakuraCtx.restore(); }); sakuraAnimationId = requestAnimationFrame(animateSakura); } 

 ย ย ย ย function startSakura() { if (sakuraAnimationId) return; if (!sakuraCanvas) return; sakuraCanvas.style.display = 'block'; setupSakura(); animateSakura(); } 

 ย ย ย ย function stopSakura() { if (!sakuraAnimationId) return; cancelAnimationFrame(sakuraAnimationId); sakuraAnimationId = null; if (sakuraCanvas) sakuraCanvas.style.display = 'none'; } 

 ย ย ย ย function setupQuantum() { if (!quantumCanvas) return; quantumCanvas.width = window.innerWidth; quantumCanvas.height = window.innerHeight; quantumCtx = quantumCanvas.getContext('2d'); quantumParticles = []; for (let i = 0; i < 200; i++) { quantumParticles.push({ x: Math.random() * quantumCanvas.width, y: Math.random() * quantumCanvas.height, size: Math.random() * 2, vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5 }); } } 

 ย ย ย ย function animateQuantum() { if (!quantumCtx) return; const w = quantumCanvas.width; const h = quantumCanvas.height; quantumCtx.fillStyle = 'rgba(10, 10, 20, 0.1)'; quantumCtx.fillRect(0, 0, w, h); quantumCtx.fillStyle = '#aaa'; quantumParticles.forEach(p => { p.x += p.vx; p.y += p.vy; if (p.x < 0 || p.x > w) p.vx *= -1; if (p.y < 0 || p.y > h) p.vy *= -1; quantumCtx.fillRect(p.x, p.y, p.size, p.size); }); quantumAnimationId = requestAnimationFrame(animateQuantum); } 

 ย ย ย ย function startQuantum() { if (quantumAnimationId) return; if (!quantumCanvas) return; quantumCanvas.style.display = 'block'; setupQuantum(); animateQuantum(); } 

 ย ย ย ย function stopQuantum() { if (!quantumAnimationId) return; cancelAnimationFrame(quantumAnimationId); quantumAnimationId = null; if (quantumCanvas) quantumCanvas.style.display = 'none'; } 

 ย ย ย ย function setupDigitalRain() { if (!digitalrainCanvas) return; digitalrainCanvas.width = window.innerWidth; digitalrainCanvas.height = window.innerHeight; digitalrainCtx = digitalrainCanvas.getContext('2d'); const columns = digitalrainCanvas.width / 20; digitalDrops = []; for (let x = 0; x < columns; x++) { digitalDrops[x] = 1; } } 

 ย ย ย ย function animateDigitalRain() { if (!digitalrainCtx) return; digitalrainCtx.fillStyle = 'rgba(0, 0, 0, 0.05)'; digitalrainCtx.fillRect(0, 0, digitalrainCanvas.width, digitalrainCanvas.height); digitalrainCtx.fillStyle = '#0FF'; digitalrainCtx.font = '15px monospace'; const chars = SUITS.concat(VALUES); for (let i = 0; i < digitalDrops.length; i++) { const text = chars[Math.floor(Math.random() * chars.length)]; digitalrainCtx.fillText(text, i * 20, digitalDrops[i] * 20); if (digitalDrops[i] * 20 > digitalrainCanvas.height && Math.random() > 0.975) { digitalDrops[i] = 0; } digitalDrops[i]++; } digitalrainAnimationId = requestAnimationFrame(animateDigitalRain); } 

 ย ย ย ย function startDigitalRain() { if (digitalrainAnimationId) return; if (!digitalrainCanvas) return; digitalrainCanvas.style.display = 'block'; setupDigitalRain(); animateDigitalRain(); } 

 ย ย ย ย function stopDigitalRain() { if (!digitalrainAnimationId) return; cancelAnimationFrame(digitalrainAnimationId); digitalrainAnimationId = null; if (digitalrainCanvas) digitalrainCanvas.style.display = 'none'; } 

 ย ย ย ย function setupSands() { if (!sandsCanvas) return; sandsCanvas.width = window.innerWidth; sandsCanvas.height = window.innerHeight; sandsCtx = sandsCanvas.getContext('2d'); sandTime = 0; } 

 ย ย ย ย function animateSands() { if (!sandsCtx) return; const w = sandsCanvas.width; const h = sandsCanvas.height; sandTime += 0.01; sandsCtx.clearRect(0, 0, w, h); for (let i = 0; i < 10; i++) { const color = `hsl(40, 50%, ${70 - i * 4}%)`; sandsCtx.fillStyle = color; sandsCtx.beginPath(); sandsCtx.moveTo(0, h); for (let x = 0; x < w; x++) { const y = h * 0.6 + Math.sin(x * 0.01 + sandTime + i * 0.5) * 20 * Math.sin(x * 0.001) + i * 20; sandsCtx.lineTo(x, y); } sandsCtx.lineTo(w, h); sandsCtx.fill(); } sandsAnimationId = requestAnimationFrame(animateSands); } 

 ย ย ย ย function startSands() { if (sandsAnimationId) return; if (!sandsCanvas) return; sandsCanvas.style.display = 'block'; setupSands(); animateSands(); } 

 ย ย ย ย function stopSands() { if (!sandsAnimationId) return; cancelAnimationFrame(sandsAnimationId); sandsAnimationId = null; if (sandsCanvas) sandsCanvas.style.display = 'none'; } 

 ย ย ย ย function setupInkBlot() { if (!inkblotCanvas) return; inkblotCanvas.width = window.innerWidth; inkblotCanvas.height = window.innerHeight; inkblotCtx = inkblotCanvas.getContext('2d'); inkblots = []; inkblotCtx.fillStyle = '#F5EEDC'; inkblotCtx.fillRect(0,0,inkblotCanvas.width, inkblotCanvas.height); const handler = (e) => { const rect = inkblotCanvas.getBoundingClientRect(); const x = (e.clientX || e.touches[0].clientX) - rect.left; const y = (e.clientY || e.touches[0].clientY) - rect.top; inkblots.push({ x, y, radius: 0, maxRadius: Math.random() * 50 + 20, speed: Math.random() * 0.5 + 0.2 }); }; inkblotCanvas.addEventListener('mousedown', handler); inkblotCanvas.addEventListener('touchstart', handler); } 

 ย ย ย ย function animateInkBlot() { if (!inkblotCtx) return; inkblotCtx.fillStyle = 'rgba(0,0,0,0.5)'; inkblots.forEach(blot => { if(blot.radius < blot.maxRadius) { blot.radius += blot.speed; } inkblotCtx.beginPath(); inkblotCtx.arc(blot.x, blot.y, blot.radius, 0, Math.PI * 2); inkblotCtx.fill(); }); inkblotAnimationId = requestAnimationFrame(animateInkBlot); } 

 ย ย ย ย function startInkBlot() { if(inkblotAnimationId) return; if(!inkblotCanvas) return; inkblotCanvas.style.display = 'block'; setupInkBlot(); animateInkBlot(); } 

 ย ย ย ย function stopInkBlot() { if(!inkblotAnimationId) return; cancelAnimationFrame(inkblotAnimationId); inkblotAnimationId = null; if(inkblotCanvas) inkblotCanvas.style.display = 'none'; } 

 ย ย ย ย function setupCosmic() { if (!cosmicCanvas) return; cosmicCanvas.width = window.innerWidth; cosmicCanvas.height = window.innerHeight; cosmicCtx = cosmicCanvas.getContext('2d'); cosmicStars = Array.from({length: 500}, () => ({x: Math.random(), y: Math.random(), z: Math.random()})); cosmicRipples = []; const handler = (e) => { const rect = cosmicCanvas.getBoundingClientRect(); const x = (e.clientX || e.touches[0].clientX) - rect.left; const y = (e.clientY || e.touches[0].clientY) - rect.top; cosmicRipples.push({x, y, radius: 0, maxRadius: 200, speed: 2}); }; cosmicCanvas.addEventListener('mousedown', handler); cosmicCanvas.addEventListener('touchstart', handler); } 

 ย ย ย ย function animateCosmic() { if (!cosmicCtx) return; const w = cosmicCanvas.width; const h = cosmicCanvas.height; cosmicCtx.fillStyle = 'black'; cosmicCtx.fillRect(0,0,w,h); cosmicRipples.forEach((r, i) => { r.radius += r.speed; if(r.radius > r.maxRadius) cosmicRipples.splice(i, 1); }); cosmicCtx.fillStyle = 'white'; cosmicStars.forEach(s => { let sx = s.x * w; let sy = s.y * h; cosmicRipples.forEach(r => { const dx = sx-r.x; const dy = sy-r.y; const dist = Math.sqrt(dx*dx + dy*dy); if(dist < r.radius) { const angle = Math.atan2(dy, dx); const warp = (1 - dist/r.radius) * 20; sx += Math.cos(angle) * warp; sy += Math.sin(angle) * warp; } }); const size = s.z * 2; cosmicCtx.fillRect(sx, sy, size, size); }); cosmicAnimationId = requestAnimationFrame(animateCosmic); } 

 ย ย ย ย function startCosmic() { if(cosmicAnimationId) return; if(!cosmicCanvas) return; cosmicCanvas.style.display = 'block'; setupCosmic(); animateCosmic(); } 

 ย ย ย ย function stopCosmic() { if(!cosmicAnimationId) return; cancelAnimationFrame(cosmicAnimationId); cosmicAnimationId = null; if(cosmicCanvas) cosmicCanvas.style.display = 'none'; } 

 ย ย ย ย function setupMusicViz() { if (!musicvizCanvas) return; musicvizCanvas.width = window.innerWidth; musicvizCanvas.height = window.innerHeight; musicvizCtx = musicvizCanvas.getContext('2d'); } 

 ย ย ย ย function animateMusicViz() { if (!musicvizCtx || !analyser) return; const w = musicvizCanvas.width; const h = musicvizCanvas.height; musicvizCtx.fillStyle = 'rgba(0,0,10,0.1)'; musicvizCtx.fillRect(0,0,w,h); const values = analyser.getValue(); const barWidth = w / values.length; for(let i=0; i<values.length; i++) { const val = (values[i] + 140) * 2; const hue = i / values.length * 360; musicvizCtx.fillStyle = `hsla(${hue}, 100%, 50%, 0.5)`; musicvizCtx.fillRect(i*barWidth, h-val, barWidth, val); } musicvizAnimationId = requestAnimationFrame(animateMusicViz); } 

 ย ย ย ย function startMusicViz() { if(musicvizAnimationId) return; if(!musicvizCanvas) return; musicvizCanvas.style.display = 'block'; setupMusicViz(); animateMusicViz(); } 

 ย ย ย ย function stopMusicViz() { if(!musicvizAnimationId) return; cancelAnimationFrame(musicvizAnimationId); musicvizAnimationId = null; if(musicvizCanvas) musicvizCanvas.style.display = 'none'; } 

 ย ย ย ย function setupBioForest() { if (!bioforestCanvas) return; bioforestCanvas.width = window.innerWidth; bioforestCanvas.height = window.innerHeight; bioforestCtx = bioforestCanvas.getContext('2d'); bioPlants = Array.from({length: 100}, () => ({x: Math.random() * bioforestCanvas.width, y: Math.random() * bioforestCanvas.height, size: Math.random() * 10 + 5, brightness: 0.1, hue: Math.random()*60 + 100})); const handler = (e) => { const rect = bioforestCanvas.getBoundingClientRect(); mousePos.x = (e.clientX || e.touches[0].clientX) - rect.left; mousePos.y = (e.clientY || e.touches[0].clientY) - rect.top; }; bioforestCanvas.addEventListener('mousemove', handler); bioforestCanvas.addEventListener('touchmove', handler); } 

 ย ย ย ย function animateBioForest() { if (!bioforestCtx) return; const w = bioforestCanvas.width; const h = bioforestCanvas.height; bioforestCtx.fillStyle = '#0a1a0a'; bioforestCtx.fillRect(0,0,w,h); bioPlants.forEach(p => { const dx = p.x - mousePos.x; const dy = p.y - mousePos.y; const dist = Math.sqrt(dx*dx + dy*dy); p.brightness = Math.max(0.1, 1 - dist/100); bioforestCtx.fillStyle = `hsla(${p.hue}, 80%, 50%, ${p.brightness})`; bioforestCtx.beginPath(); bioforestCtx.arc(p.x, p.y, p.size, 0, Math.PI*2); bioforestCtx.fill(); }); bioforestAnimationId = requestAnimationFrame(animateBioForest); } 

 ย ย ย ย function startBioForest() { if(bioforestAnimationId) return; if(!bioforestCanvas) return; bioforestCanvas.style.display = 'block'; setupBioForest(); animateBioForest(); } 

 ย ย ย ย function stopBioForest() { if(!bioforestAnimationId) return; cancelAnimationFrame(bioforestAnimationId); bioforestAnimationId = null; if(bioforestCanvas) bioforestCanvas.style.display = 'none'; } 

 ย ย ย ย function setupWatery() { if (!wateryCanvas) return; wateryCanvas.width = window.innerWidth/4; wateryCanvas.height = window.innerHeight/4; wateryCtx = wateryCanvas.getContext('2d'); wateryRipples = []; const handler = (e) => { const rect = wateryCanvas.getBoundingClientRect(); const x = ((e.clientX || e.touches[0].clientX) - rect.left) / 4; const y = ((e.clientY || e.touches[0].clientY) - rect.top) / 4; wateryRipples.push({x, y, radius: 0, maxRadius: 50, speed: 1}); }; wateryCanvas.addEventListener('mousedown', handler); wateryCanvas.addEventListener('touchstart', handler); } 

 ย ย ย ย function animateWatery() { if (!wateryCtx) return; const w = wateryCanvas.width; const h = wateryCanvas.height; wateryCtx.fillStyle = '#3498db'; wateryCtx.fillRect(0,0,w,h); wateryRipples.forEach((r,i) => { r.radius += r.speed; if(r.radius > r.maxRadius) wateryRipples.splice(i,1); wateryCtx.strokeStyle = `rgba(255,255,255, ${1 - r.radius/r.maxRadius})`; wateryCtx.lineWidth = 2; wateryCtx.beginPath(); wateryCtx.arc(r.x, r.y, r.radius, 0, Math.PI*2); wateryCtx.stroke(); }); wateryAnimationId = requestAnimationFrame(animateWatery); } 

 ย ย ย ย function startWatery() { if(wateryAnimationId) return; if(!wateryCanvas) return; wateryCanvas.style.display = 'block'; setupWatery(); animateWatery(); } 

 ย ย ย ย function stopWatery() { if(!wateryAnimationId) return; cancelAnimationFrame(wateryAnimationId); wateryAnimationId = null; if(wateryCanvas) wateryCanvas.style.display = 'none'; } 

 ย ย ย ย function setupStainedGlass() { if (!stainedglassCanvas) return; stainedglassCanvas.width = window.innerWidth; stainedglassCanvas.height = window.innerHeight; stainedglassCtx = stainedglassCanvas.getContext('2d'); glassPanes = []; const cols = 20; const rows = 15; const paneWidth = stainedglassCanvas.width / cols; const paneHeight = stainedglassCanvas.height / rows; for (let i = 0; i < cols; i++) { for (let j = 0; j < rows; j++) { glassPanes.push({ x: i * paneWidth, y: j * paneHeight, width: paneWidth, height: paneHeight, hue: Math.random() * 360, brightness: 0.2 }); } } } 

 ย ย ย ย function animateStainedGlass() { if (!stainedglassCtx) return; const w = stainedglassCanvas.width; const h = stainedglassCanvas.height; stainedglassCtx.fillStyle = 'black'; stainedglassCtx.fillRect(0, 0, w, h); glassPanes.forEach(p => { const dx = (p.x + p.width / 2) - mousePos.x; const dy = (p.y + p.height / 2) - mousePos.y; const dist = Math.sqrt(dx * dx + dy * dy); p.brightness = Math.max(0.2, 1 - dist / 300); stainedglassCtx.fillStyle = `hsl(${p.hue}, 80%, ${p.brightness * 50}%)`; stainedglassCtx.fillRect(p.x, p.y, p.width, p.height); stainedglassCtx.strokeStyle = 'black'; stainedglassCtx.lineWidth = 4; stainedglassCtx.strokeRect(p.x, p.y, p.width, p.height); }); stainedglassAnimationId = requestAnimationFrame(animateStainedGlass); } 

 ย ย ย ย function startStainedGlass() { if (stainedglassAnimationId) return; if (!stainedglassCanvas) return; stainedglassCanvas.style.display = 'block'; setupStainedGlass(); animateStainedGlass(); } 

 ย ย ย ย function stopStainedGlass() { if (!stainedglassAnimationId) return; cancelAnimationFrame(stainedglassAnimationId); stainedglassAnimationId = null; if (stainedglassCanvas) stainedglassCanvas.style.display = 'none'; } 

 ย ย ย ย function setupSwarm() { if (!swarmCanvas) return; swarmCanvas.width = window.innerWidth; swarmCanvas.height = window.innerHeight; swarmCtx = swarmCanvas.getContext('2d'); swarmParticles = []; for (let i = 0; i < 200; i++) { swarmParticles.push({ x: Math.random() * swarmCanvas.width, y: Math.random() * swarmCanvas.height, size: Math.random() * 2 + 1, vx: 0, vy: 0 }); } } 

 ย ย ย ย function animateSwarm() { if (!swarmCtx) return; const w = swarmCanvas.width; const h = swarmCanvas.height; swarmCtx.fillStyle = 'rgba(0,0,0,0.2)'; swarmCtx.fillRect(0, 0, w, h); swarmParticles.forEach(p => { const dx = p.x - mousePos.x; const dy = p.y - mousePos.y; const dist = Math.sqrt(dx * dx + dy * dy); const maxDist = 100; if (dist < maxDist) { const force = (maxDist - dist) / maxDist; p.vx += (dx / dist) * force * 0.5; p.vy += (dy / dist) * force * 0.5; } p.vx *= 0.95; p.vy *= 0.95; p.vx += (Math.random() - 0.5) * 0.1; p.vy += (Math.random() - 0.5) * 0.1; p.x += p.vx; p.y += p.vy; if (p.x > w || p.x < 0) p.vx *= -1; if (p.y > h || p.y < 0) p.vy *= -1; swarmCtx.fillStyle = 'white'; swarmCtx.fillRect(p.x, p.y, p.size, p.size); }); swarmAnimationId = requestAnimationFrame(animateSwarm); } 

 ย ย ย ย function startSwarm() { if (swarmAnimationId) return; if (!swarmCanvas) return; swarmCanvas.style.display = 'block'; setupSwarm(); animateSwarm(); } 

 ย ย ย ย function stopSwarm() { if (!swarmAnimationId) return; cancelAnimationFrame(swarmAnimationId); swarmAnimationId = null; if (swarmCanvas) swarmCanvas.style.display = 'none'; } 

 ย ย ย ย function setupGlitch() { if (!glitchCanvas) return; glitchCanvas.width = window.innerWidth; glitchCanvas.height = window.innerHeight; glitchCtx = glitchCanvas.getContext('2d'); glitchCtx.fillStyle = 'black'; glitchCtx.fillRect(0,0,glitchCanvas.width, glitchCanvas.height); glitchCtx.font = "bold 15vw 'Courier New'"; glitchCtx.textAlign = 'center'; glitchCtx.textBaseline = 'middle'; glitchCtx.fillStyle = '#0f0'; glitchCtx.fillText('SOLITAIRE', glitchCanvas.width/2, glitchCanvas.height/2); glitchData = glitchCtx.getImageData(0,0,glitchCanvas.width, glitchCanvas.height); } 

 ย ย ย ย function animateGlitch() { if (!glitchCtx) return; const w = glitchCanvas.width; const h = glitchCanvas.height; if (Math.random() > 0.9) { const tempImgData = new ImageData(new Uint8ClampedArray(glitchData.data), w, h); const data = tempImgData.data; const glitchAmount = Math.floor(mousePos.x / w * 50); for (let i = 0; i < 10; i++) { const y = Math.floor(Math.random() * h); const rowOffset = (Math.floor(Math.random() * glitchAmount) - glitchAmount / 2) * 4; const row = tempImgData.data.slice(y * w * 4, (y + 1) * w * 4); for (let x = 0; x < w * 4; x++) { data[y * w * 4 + x] = row[(x + rowOffset + w * 4) % (w * 4)]; } } glitchCtx.putImageData(tempImgData, 0, 0); } glitchAnimationId = requestAnimationFrame(animateGlitch); } 

 ย ย ย ย function startGlitch() { if (glitchAnimationId) return; if (!glitchCanvas) return; glitchCanvas.style.display = 'block'; setupGlitch(); animateGlitch(); } 

 ย ย ย ย function stopGlitch() { if (!glitchAnimationId) return; cancelAnimationFrame(glitchAnimationId); glitchAnimationId = null; if (glitchCanvas) glitchCanvas.style.display = 'none'; } 

 ย ย ย ย function setupAurora() { if (!auroraCanvas) return; auroraCanvas.width = window.innerWidth; auroraCanvas.height = window.innerHeight; auroraCtx = auroraCanvas.getContext('2d'); auroraParticles = []; for (let i = 0; i < 3; i++) { for (let j = 0; j < 50; j++) { auroraParticles.push({ x: Math.random() * auroraCanvas.width, y: Math.random() * auroraCanvas.height, vx: 0, vy: 0, hue: 120 + i * 40, life: Math.random() * 100 }); } } } 

 ย ย ย ย function animateAurora() { if (!auroraCtx) return; const w = auroraCanvas.width; const h = auroraCanvas.height; auroraCtx.globalCompositeOperation = 'source-over'; auroraCtx.fillStyle = 'rgba(0,0,10,0.1)'; auroraCtx.fillRect(0,0,w,h); auroraCtx.globalCompositeOperation = 'lighter'; auroraParticles.forEach(p => { const dx = p.x - mousePos.x; const dy = p.y - mousePos.y; const dist = Math.sqrt(dx*dx + dy*dy); const angle = Math.sin(p.x / 100) + Math.sin(p.y / 100) + Date.now() * 0.0001; p.vx += Math.cos(angle) * 0.1; p.vy += Math.sin(angle) * 0.1; if (dist < 150) { p.vx += (dx / dist) * (1 - dist / 150) * 0.5; p.vy += (dy / dist) * (1 - dist / 150) * 0.5; } p.vx *= 0.98; p.vy *= 0.98; p.x += p.vx; p.y += p.vy; p.life--; if (p.life <= 0 || p.x < 0 || p.x > w || p.y < 0 || p.y > h) { p.x = Math.random() * w; p.y = Math.random() * h; p.vx = 0; p.vy = 0; p.life = 100; } auroraCtx.fillStyle = `hsla(${p.hue}, 100%, 50%, ${p.life/100 * 0.1})`; auroraCtx.beginPath(); auroraCtx.arc(p.x, p.y, 2, 0, Math.PI*2); auroraCtx.fill(); }); auroraAnimationId = requestAnimationFrame(animateAurora); } 

 ย ย ย ย function startAurora() { if (auroraAnimationId) return; if (!auroraCanvas) return; auroraCanvas.style.display = 'block'; setupAurora(); animateAurora(); } 

 ย ย ย ย function stopAurora() { if (!auroraAnimationId) return; cancelAnimationFrame(auroraAnimationId); auroraAnimationId = null; if (auroraCanvas) auroraCanvas.style.display = 'none'; } 

 ย ย ย ย function setupConstellation() { if (!constellationCanvas) return; constellationCanvas.width = window.innerWidth; constellationCanvas.height = window.innerHeight; constellationCtx = constellationCanvas.getContext('2d'); constellationStars = []; for (let i = 0; i < 200; i++) { constellationStars.push({ x: Math.random() * constellationCanvas.width, y: Math.random() * constellationCanvas.height, size: Math.random() * 2 + 1 }); } } 

 ย ย ย ย function animateConstellation() { if (!constellationCtx) return; const w = constellationCanvas.width; const h = constellationCanvas.height; constellationCtx.fillStyle = 'black'; constellationCtx.fillRect(0,0,w,h); constellationStars.forEach(s1 => { const dx = s1.x - mousePos.x; const dy = s1.y - mousePos.y; const dist = Math.sqrt(dx*dx + dy*dy); const brightness = Math.max(0.2, 1 - dist / 200); constellationCtx.fillStyle = `rgba(255,255,255, ${brightness})`; constellationCtx.beginPath(); constellationCtx.arc(s1.x, s1.y, s1.size * brightness, 0, Math.PI*2); constellationCtx.fill(); constellationStars.forEach(s2 => { if (s1 === s2) return; const lineDist = Math.sqrt(Math.pow(s1.x - s2.x, 2) + Math.pow(s1.y - s2.y, 2)); if (lineDist < 100) { const lineOpacity = 1 - lineDist / 100; constellationCtx.strokeStyle = `rgba(255,255,255, ${lineOpacity * brightness * 0.5})`; constellationCtx.lineWidth = 0.5; constellationCtx.beginPath(); constellationCtx.moveTo(s1.x, s1.y); constellationCtx.lineTo(s2.x, s2.y); constellationCtx.stroke(); } }); }); constellationAnimationId = requestAnimationFrame(animateConstellation); } 

 ย ย ย ย function startConstellation() { if (constellationAnimationId) return; if (!constellationCanvas) return; constellationCanvas.style.display = 'block'; setupConstellation(); animateConstellation(); } 

 ย ย ย ย function stopConstellation() { if (!constellationAnimationId) return; cancelAnimationFrame(constellationAnimationId); constellationAnimationId = null; if (constellationCanvas) constellationCanvas.style.display = 'none'; } 

 ย ย ย ย function setupSynthwave() { if (!synthwaveCanvas) return; synthwaveCanvas.width = window.innerWidth; synthwaveCanvas.height = window.innerHeight; synthwaveCtx = synthwaveCanvas.getContext('2d'); synthwaveTime = 0; } 

 ย ย ย ย function animateSynthwave() { if (!synthwaveCtx) return; const w = synthwaveCanvas.width; const h = synthwaveCanvas.height; synthwaveTime += 0.01; synthwaveCtx.fillStyle = '#21003c'; synthwaveCtx.fillRect(0, 0, w, h); const sunGradient = synthwaveCtx.createRadialGradient(w / 2, h / 2, 50, w / 2, h / 2, 200); sunGradient.addColorStop(0, '#ffcc00'); sunGradient.addColorStop(1, 'rgba(255, 100, 0, 0)'); synthwaveCtx.fillStyle = sunGradient; synthwaveCtx.fillRect(0, 0, w, h); synthwaveCtx.strokeStyle = '#ff00ff'; synthwaveCtx.lineWidth = 2; for (let i = 0; i < 20; i++) { const y = h / 2 + i * i; const p = (y - h / 2) / (h / 2); synthwaveCtx.beginPath(); synthwaveCtx.moveTo(0, y); synthwaveCtx.lineTo(w, y); synthwaveCtx.stroke(); } for (let i = -20; i < 20; i++) { synthwaveCtx.beginPath(); synthwaveCtx.moveTo(w / 2, h / 2); synthwaveCtx.lineTo(w / 2 + Math.tan(p * 1.4 - 0.7) * w, h); synthwaveCtx.stroke(); } synthwaveAnimationId = requestAnimationFrame(animateSynthwave); } 

 ย ย ย ย function startSynthwave() { if (synthwaveAnimationId) return; if (!synthwaveCanvas) return; synthwaveCanvas.style.display = 'block'; setupSynthwave(); animateSynthwave(); } 

 ย ย ย ย function stopSynthwave() { if (!synthwaveAnimationId) return; cancelAnimationFrame(synthwaveAnimationId); synthwaveAnimationId = null; if (synthwaveCanvas) synthwaveCanvas.style.display = 'none'; } 

 ย ย ย ย function setupNebula() { if (!nebulaCanvas) return; nebulaCanvas.width = window.innerWidth; nebulaCanvas.height = window.innerHeight; nebulaCtx = nebulaCanvas.getContext('2d'); nebulaParticles = []; for (let i = 0; i < 200; i++) { nebulaParticles.push({ x: Math.random() * nebulaCanvas.width, y: Math.random() * nebulaCanvas.height, size: Math.random() * 2, hue: Math.random() * 60 + 240 }); } } 

 ย ย ย ย function animateNebula() { if (!nebulaCtx) return; const w = nebulaCanvas.width; const h = nebulaCanvas.height; nebulaCtx.globalCompositeOperation = 'source-over'; nebulaCtx.fillStyle = 'rgba(0, 0, 10, 0.1)'; nebulaCtx.fillRect(0, 0, w, h); nebulaCtx.globalCompositeOperation = 'lighter'; nebulaParticles.forEach(p => { p.x += (Math.random() - 0.5); p.y += (Math.random() - 0.5); if (p.x < 0 || p.x > w || p.y < 0 || p.y > h) { p.x = Math.random() * w; p.y = Math.random() * h; } const gradient = nebulaCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 20); gradient.addColorStop(0, `hsla(${p.hue}, 100%, 70%, 0.2)`); gradient.addColorStop(1, `hsla(${p.hue}, 100%, 70%, 0)`); nebulaCtx.fillStyle = gradient; nebulaCtx.fillRect(0, 0, w, h); }); nebulaAnimationId = requestAnimationFrame(animateNebula); } 

 ย ย ย ย function startNebula() { if (nebulaAnimationId) return; if (!nebulaCanvas) return; nebulaCanvas.style.display = 'block'; setupNebula(); animateNebula(); } 

 ย ย ย ย function stopNebula() { if (!nebulaAnimationId) return; cancelAnimationFrame(nebulaAnimationId); nebulaAnimationId = null; if (nebulaCanvas) nebulaCanvas.style.display = 'none'; } 

 ย ย ย ย function setupJungle() { if (!jungleCanvas) return; jungleCanvas.width = window.innerWidth; jungleCanvas.height = window.innerHeight; jungleCtx = jungleCanvas.getContext('2d'); jungleVines = []; for (let i = 0; i < 20; i++) { jungleVines.push({ x: Math.random() * jungleCanvas.width, len: Math.random() * 200 + 100, angle: 0 }); } } 

 ย ย ย ย function animateJungle() { if (!jungleCtx) return; const w = jungleCanvas.width; const h = jungleCanvas.height; jungleCtx.fillStyle = '#0c2e12'; jungleCtx.fillRect(0, 0, w, h); jungleVines.forEach(v => { v.angle += 0.01; jungleCtx.strokeStyle = '#3a5f0b'; jungleCtx.lineWidth = 5; jungleCtx.beginPath(); jungleCtx.moveTo(v.x, 0); jungleCtx.quadraticCurveTo(v.x + Math.sin(v.angle) * 50, v.len / 2, v.x, v.len); jungleCtx.stroke(); }); jungleAnimationId = requestAnimationFrame(animateJungle); } 

 ย ย ย ย function startJungle() { if (jungleAnimationId) return; if (!jungleCanvas) return; jungleCanvas.style.display = 'block'; setupJungle(); animateJungle(); } 

 ย ย ย ย function stopJungle() { if (!jungleAnimationId) return; cancelAnimationFrame(jungleAnimationId); jungleAnimationId = null; if (jungleCanvas) jungleCanvas.style.display = 'none'; } 

 ย ย ย ย function setupCityscape() { if (!cityscapeCanvas) return; cityscapeCanvas.width = window.innerWidth; cityscapeCanvas.height = window.innerHeight; cityscapeCtx = cityscapeCanvas.getContext('2d'); cityscapeWindows = []; for (let i = 0; i < 300; i++) { cityscapeWindows.push({ x: Math.random() * cityscapeCanvas.width, y: Math.random() * cityscapeCanvas.height, on: Math.random() > 0.8 }); } } 

 ย ย ย ย function animateCityscape() { if (!cityscapeCtx) return; const w = cityscapeCanvas.width; const h = cityscapeCanvas.height; cityscapeCtx.fillStyle = '#0a0a1a'; cityscapeCtx.fillRect(0, 0, w, h); cityscapeWindows.forEach(win => { if (Math.random() > 0.995) win.on = !win.on; if (win.on) { cityscapeCtx.fillStyle = '#ffffaa'; cityscapeCtx.fillRect(win.x, win.y, 4, 6); } }); cityscapeAnimationId = requestAnimationFrame(animateCityscape); } 

 ย ย ย ย function startCityscape() { if (cityscapeAnimationId) return; if (!cityscapeCanvas) return; cityscapeCanvas.style.display = 'block'; setupCityscape(); animateCityscape(); } 

 ย ย ย ย function stopCityscape() { if (!cityscapeAnimationId) return; cancelAnimationFrame(cityscapeAnimationId); cityscapeAnimationId = null; if (cityscapeCanvas) cityscapeCanvas.style.display = 'none'; } 

 ย ย ย ย function setupPaint() { if (!paintCanvas) return; paintCanvas.width = window.innerWidth; paintCanvas.height = window.innerHeight; paintCtx = paintCanvas.getContext('2d'); paintBlobs = []; for (let i = 0; i < 15; i++) { paintBlobs.push({ x: Math.random() * paintCanvas.width, y: Math.random() * paintCanvas.height, vx: (Math.random() - 0.5), vy: (Math.random() - 0.5), radius: Math.random() * 100 + 50, hue: Math.random() * 360 }); } } 

 ย ย ย ย function animatePaint() { if (!paintCtx) return; const w = paintCanvas.width; const h = paintCanvas.height; paintCtx.globalCompositeOperation = 'source-over'; paintCtx.fillStyle = 'rgba(255, 255, 255, 0.05)'; paintCtx.fillRect(0, 0, w, h); paintCtx.globalCompositeOperation = 'lighter'; paintBlobs.forEach(b => { b.x += b.vx; b.y += b.vy; if (b.x < 0 || b.x > w) b.vx *= -1; if (b.y < 0 || b.y > h) b.vy *= -1; paintCtx.fillStyle = `hsla(${b.hue}, 100%, 50%, 0.05)`; paintCtx.beginPath(); paintCtx.arc(b.x, b.y, b.radius, 0, Math.PI * 2); paintCtx.fill(); }); paintAnimationId = requestAnimationFrame(animatePaint); } 

 ย ย ย ย function startPaint() { if (paintAnimationId) return; if (!paintCanvas) return; paintCanvas.style.display = 'block'; setupPaint(); animatePaint(); } 

 ย ย ย ย function stopPaint() { if (!paintAnimationId) return; cancelAnimationFrame(paintAnimationId); paintAnimationId = null; if (paintCanvas) paintCanvas.style.display = 'none'; } 

 ย ย ย ย function setupLaserGrid() { if (!laserGridCanvas) return; laserGridCanvas.width = window.innerWidth; laserGridCanvas.height = window.innerHeight; laserGridCtx = laserGridCanvas.getContext('2d'); laserGridTime = 0; } 

 ย ย ย ย function animateLaserGrid() { if (!laserGridCtx) return; const w = laserGridCanvas.width; const h = laserGridCanvas.height; laserGridTime += 0.02; laserGridCtx.fillStyle = '#00001a'; laserGridCtx.fillRect(0, 0, w, h); const horizon = h / 2.2; for(let i = 0; i < 40; i++) { const p = 1 - (i / 40); laserGridCtx.strokeStyle = `rgba(255, 0, 255, ${p * 0.5})`; laserGridCtx.lineWidth = p * 2; laserGridCtx.beginPath(); const y = horizon + Math.pow(i, 1.8); laserGridCtx.moveTo(0, y); laserGridCtx.lineTo(w, y); laserGridCtx.stroke(); } laserGridCtx.strokeStyle = '#00ffff'; for (let i = 0; i < 40; i++) { const p = i / 40; laserGridCtx.beginPath(); laserGridCtx.moveTo(w / 2, horizon); laserGridCtx.lineTo(w / 2 + Math.tan(p * 1.4 - 0.7) * w, h); laserGridCtx.stroke(); } laserGridAnimationId = requestAnimationFrame(animateLaserGrid); } 

 ย ย ย ย function startLaserGrid() { if (laserGridAnimationId) return; if (!laserGridCanvas) return; laserGridCanvas.style.display = 'block'; setupLaserGrid(); animateLaserGrid(); } 

 ย ย ย ย function stopLaserGrid() { if (!laserGridAnimationId) return; cancelAnimationFrame(laserGridAnimationId); laserGridAnimationId = null; if (laserGridCanvas) laserGridCanvas.style.display = 'none'; } 

 ย ย ย ย function setupNeonPalms() { if (!neonPalmsCanvas) return; neonPalmsCanvas.width = window.innerWidth; neonPalmsCanvas.height = window.innerHeight; neonPalmsCtx = neonPalmsCanvas.getContext('2d'); neonPalmsTime = 0; } 

 ย ย ย ย function animateNeonPalms() { if (!neonPalmsCtx) return; const w = neonPalmsCanvas.width; const h = neonPalmsCanvas.height; neonPalmsTime += 0.01; const bgGrad = neonPalmsCtx.createLinearGradient(0, 0, 0, h); bgGrad.addColorStop(0, '#10002b'); bgGrad.addColorStop(0.5, '#2c003e'); bgGrad.addColorStop(1, '#ff00ff'); neonPalmsCtx.fillStyle = bgGrad; neonPalmsCtx.fillRect(0, 0, w, h); neonPalmsCtx.strokeStyle = '#00ffff'; neonPalmsCtx.lineWidth = 3; [-w * 0.1, w * 0.6].forEach(baseX => { neonPalmsCtx.beginPath(); neonPalmsCtx.moveTo(baseX, h); for(let i = 0; i < 80; i++) { neonPalmsCtx.lineTo(baseX + i, h - i * 1.5); } neonPalmsCtx.stroke(); for(let i = 0; i < 8; i++) { neonPalmsCtx.beginPath(); const angle = (i/7) * Math.PI - (Math.PI / 14) + Math.sin(neonPalmsTime + baseX) * 0.1; const len = 100 + i % 2 * 20; neonPalmsCtx.moveTo(baseX + 79, h - 118.5); neonPalmsCtx.quadraticCurveTo(baseX + 79 + Math.cos(angle) * len * 0.5, h - 118.5 - Math.sin(angle) * len * 0.5, baseX + 79 + Math.cos(angle) * len, h - 118.5 - Math.sin(angle) * len); neonPalmsCtx.stroke(); } }); neonPalmsAnimationId = requestAnimationFrame(animateNeonPalms); } 

 ย ย ย ย function startNeonPalms() { if (neonPalmsAnimationId) return; if (!neonPalmsCanvas) return; neonPalmsCanvas.style.display = 'block'; setupNeonPalms(); animateNeonPalms(); } 

 ย ย ย ย function stopNeonPalms() { if (!neonPalmsAnimationId) return; cancelAnimationFrame(neonPalmsAnimationId); neonPalmsAnimationId = null; if (neonPalmsCanvas) neonPalmsCanvas.style.display = 'none'; } 

 ย ย ย ย function setupMemphis() { if (!memphisCanvas) return; memphisCanvas.width = window.innerWidth; memphisCanvas.height = window.innerHeight; memphisCtx = memphisCanvas.getContext('2d'); memphisShapes = []; const colors = ['#ffc107', '#00bcd4', '#e91e63', '#4caf50', '#3f51b5']; for (let i = 0; i < 50; i++) { memphisShapes.push({ type: ['circle', 'rect', 'triangle', 'squiggle'][Math.floor(Math.random() * 4)], x: Math.random() * memphisCanvas.width, y: Math.random() * memphisCanvas.height, size: Math.random() * 50 + 20, color: colors[Math.floor(Math.random() * colors.length)], angle: Math.random() * Math.PI * 2, speed: (Math.random() - 0.5) * 0.01 }); } } 

 ย ย ย ย function animateMemphis() { if (!memphisCtx) return; const w = memphisCanvas.width; const h = memphisCanvas.height; memphisCtx.fillStyle = '#f0f0f0'; memphisCtx.fillRect(0, 0, w, h); memphisShapes.forEach(s => { s.angle += s.speed; memphisCtx.fillStyle = s.color; memphisCtx.save(); memphisCtx.translate(s.x, s.y); memphisCtx.rotate(s.angle); if (s.type === 'rect') { memphisCtx.fillRect(-s.size / 2, -s.size / 2, s.size, s.size); } else if (s.type === 'circle') { memphisCtx.beginPath(); memphisCtx.arc(0, 0, s.size / 2, 0, Math.PI * 2); memphisCtx.fill(); } else if (s.type === 'triangle') { memphisCtx.beginPath(); memphisCtx.moveTo(0, -s.size / 2); memphisCtx.lineTo(-s.size / 2, s.size / 2); memphisCtx.lineTo(s.size / 2, s.size / 2); memphisCtx.closePath(); memphisCtx.fill(); } else if (s.type === 'squiggle') { memphisCtx.strokeStyle = s.color; memphisCtx.lineWidth = s.size/5; memphisCtx.beginPath(); memphisCtx.moveTo(-s.size/2, 0); memphisCtx.quadraticCurveTo(0, -s.size/2, 0, 0); memphisCtx.quadraticCurveTo(0, s.size/2, s.size/2, 0); memphisCtx.stroke(); } memphisCtx.restore(); }); memphisAnimationId = requestAnimationFrame(animateMemphis); } 

 ย ย ย ย function startMemphis() { if (memphisAnimationId) return; if (!memphisCanvas) return; memphisCanvas.style.display = 'block'; setupMemphis(); animateMemphis(); } 

 ย ย ย ย function stopMemphis() { if (!memphisAnimationId) return; cancelAnimationFrame(memphisAnimationId); memphisAnimationId = null; if (memphisCanvas) memphisCanvas.style.display = 'none'; } 

 ย ย ย ย function setupCassette() { if (!cassetteCanvas) return; cassetteCanvas.width = window.innerWidth; cassetteCanvas.height = window.innerHeight; cassetteCtx = cassetteCanvas.getContext('2d'); cassetteTime = 0; } 

 ย ย ย ย function animateCassette() { if (!cassetteCtx) return; const w = cassetteCanvas.width; const h = cassetteCanvas.height; cassetteTime += 0.1; cassetteCtx.fillStyle = '#444'; cassetteCtx.fillRect(0, 0, w, h); cassetteCtx.save(); cassetteCtx.translate(w / 2, h / 2); cassetteCtx.fillStyle = '#aaa'; cassetteCtx.fillRect(-150, -90, 300, 180); cassetteCtx.fillStyle = '#222'; cassetteCtx.fillRect(-140, -80, 280, 160); cassetteCtx.fillStyle = '#fff'; cassetteCtx.fillRect(-130, -70, 260, 50); cassetteCtx.fillStyle = '#222'; for (let i = 0; i < 2; i++) { const x = -75 + i * 150; cassetteCtx.beginPath(); cassetteCtx.arc(x, 20, 30, 0, Math.PI * 2); cassetteCtx.fill(); cassetteCtx.save(); cassetteCtx.translate(x, 20); cassetteCtx.rotate(cassetteTime); cassetteCtx.fillStyle = '#444'; for (let j = 0; j < 6; j++) { cassetteCtx.fillRect(-5, -25, 10, 50); cassetteCtx.rotate(Math.PI / 3); } cassetteCtx.restore(); } cassetteCtx.restore(); cassetteAnimationId = requestAnimationFrame(animateCassette); } 

 ย ย ย ย function startCassette() { if (cassetteAnimationId) return; if (!cassetteCanvas) return; cassetteCanvas.style.display = 'block'; setupCassette(); animateCassette(); } 

 ย ย ย ย function stopCassette() { if (!cassetteAnimationId) return; cancelAnimationFrame(cassetteAnimationId); cassetteAnimationId = null; if (cassetteCanvas) cassetteCanvas.style.display = 'none'; } 

 ย ย ย ย function setupEightBitCity() { if (!eightBitCityCanvas) return; const w = eightBitCityCanvas.width = window.innerWidth; const h = eightBitCityCanvas.height = window.innerHeight; eightBitCityCtx = eightBitCityCanvas.getContext('2d'); eightBitCityBuildings = []; const bw = 40; for (let i = 0; i < w/bw; i++) { eightBitCityBuildings.push({ x: i * bw, h: Math.random() * (h * 0.6) + h * 0.1 }); } } 

 ย ย ย ย function animateEightBitCity() { if (!eightBitCityCtx) return; const w = eightBitCityCanvas.width; const h = eightBitCityCanvas.height; eightBitCityCtx.fillStyle = '#000022'; eightBitCityCtx.fillRect(0, 0, w, h); eightBitCityBuildings.forEach(b => { eightBitCityCtx.fillStyle = '#222'; eightBitCityCtx.fillRect(b.x, h - b.h, 40, b.h); if (Math.random() > 0.7) { eightBitCityCtx.fillStyle = '#ffff00'; eightBitCityCtx.fillRect(b.x + Math.floor(Math.random() * 7) * 4 + 4, h - b.h + Math.floor(Math.random() * (b.h / 6)) * 6, 2, 4); } }); eightBitCityAnimationId = requestAnimationFrame(animateEightBitCity); } 

 ย ย ย ย function startEightBitCity() { if (eightBitCityAnimationId) return; if (!eightBitCityCanvas) return; eightBitCityCanvas.style.display = 'block'; setupEightBitCity(); animateEightBitCity(); } 

 ย ย ย ย function stopEightBitCity() { if (!eightBitCityAnimationId) return; cancelAnimationFrame(eightBitCityAnimationId); eightBitCityAnimationId = null; if (eightBitCityCanvas) eightBitCityCanvas.style.display = 'none'; } 





 ย ย ย ย /** 

 ย ย ย ย ย* Updates all visual styles based on player selections (card backs, boards). 

 ย ย ย ย ย*/ 

 ย ย ย ย function updateCardStyles() { 

 ย ย ย ย ย ย gameBoard.dataset.backStyle = selectedBack; 

 ย ย ย ย ย ย gameBoard.dataset.faceStyle = faceStyle; 



 ย ย ย ย ย ย // Stop all currently running background animations 

 ย ย ย ย ย ย stopLavalamp(); stopStarfield(); stopOcean(); stopMatrix(); stopGeometric(); 

 ย ย ย ย ย ย stopFire(); stopRain(); stopHyperspace(); stopPlasma(); stopForest(); 

 ย ย ย ย ย ย stopNeonGrid(); stopSakura(); stopQuantum(); stopDigitalRain(); stopSands(); 

 ย ย ย ย ย ย stopInkBlot(); stopCosmic(); stopMusicViz(); stopBioForest(); stopWatery(); 

 ย ย ย ย ย ย stopStainedGlass(); stopSwarm(); stopGlitch(); stopAurora(); stopConstellation(); 

 ย ย ย ย ย ย stopSynthwave(); stopNebula(); stopJungle(); stopCityscape(); stopPaint(); 

 ย ย ย ย ย ย stopLaserGrid(); stopNeonPalms(); stopMemphis(); stopCassette(); stopEightBitCity(); 

 ย ย ย ย ย ย document.body.style.backgroundImage = 'none'; 



 ย ย ย ย ย ย let backgroundSet = false; 

 ย ย ย ย ย ย const backgroundMap = { 

 ย ย ย ย ย ย ย ย 'board-1': startLavalamp, 'board-2': startStarfield, 'board-3': startOcean, 

 ย ย ย ย ย ย ย ย 'board-4': startMatrix, 'board-5': startGeometric, 'board-6': startFire, 

 ย ย ย ย ย ย ย ย 'board-7': startRain, 'board-8': startHyperspace, 'board-9': startPlasma, 

 ย ย ย ย ย ย ย ย 'board-10': startForest, 'board-11': startNeonGrid, 'board-12': startSakura, 

 ย ย ย ย ย ย ย ย 'board-13': startQuantum, 'board-14': startDigitalRain, 'board-15': startSands, 

 ย ย ย ย ย ย ย ย 'board-16': startInkBlot, 'board-17': startCosmic, 'board-18': startMusicViz, 

 ย ย ย ย ย ย ย ย 'board-19': startBioForest, 'board-20': startStainedGlass, 'board-21': startWatery, 

 ย ย ย ย ย ย ย ย 'board-22': startSwarm, 'board-23': startGlitch, 'board-24': startAurora, 

 ย ย ย ย ย ย ย ย 'board-25': startConstellation, 'board-26': startSynthwave, 'board-27': startNebula, 

 ย ย ย ย ย ย ย ย 'board-28': startJungle, 'board-29': startCityscape, 'board-30': startPaint, 

 ย ย ย ย ย ย ย ย 'board-31': startLaserGrid, 'board-32': startNeonPalms, 'board-33': startMemphis, 

 ย ย ย ย ย ย ย ย 'board-34': startCassette, 'board-35': startEightBitCity, 

 ย ย ย ย ย ย }; 



 ย ย ย ย ย ย if (backgroundMap[selectedBoard]) { 

 ย ย ย ย ย ย ย ย backgroundMap[selectedBoard](); 

 ย ย ย ย ย ย ย ย document.body.style.backgroundColor = 'transparent'; 

 ย ย ย ย ย ย ย ย backgroundSet = true; 

 ย ย ย ย ย ย } 



 ย ย ย ย ย ย // Set a default procedural background if no animated one is selected 

 ย ย ย ย ย ย if (!backgroundSet) { 

 ย ย ย ย ย ย ย ย const boardIndex = BOARD_DATA.findIndex(b => b.id === selectedBoard); 

 ย ย ย ย ย ย ย ย if (boardIndex > -1) { 

 ย ย ย ย ย ย ย ย ย ย const color = `hsl(${boardIndex * 7.2}, 50%, 20%)`; 

 ย ย ย ย ย ย ย ย ย ย document.body.style.backgroundColor = color; 

 ย ย ย ย ย ย ย ย ย ย document.body.style.backgroundImage = `linear-gradient(45deg, rgba(0,0,0,0.1) 25%, transparent 25%), linear-gradient(-45deg, rgba(0,0,0,0.1) 25%, transparent 25%)`; 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย // Dynamically generate CSS rules for the various card back designs 

 ย ย ย ย ย ย const styleSheet = document.styleSheets[0]; 

 ย ย ย ย ย ย CARD_BACKS.forEach((back) => { 

 ย ย ย ย ย ย ย ย if (back.type === 'procedural') { 

 ย ย ย ย ย ย ย ย ย ย const i = parseInt(back.id.split('-')[1]); 

 ย ย ย ย ย ย ย ย ย ย const color1 = `hsl(${i * 7.2}, 70%, 50%)`; 

 ย ย ย ย ย ย ย ย ย ย const color2 = `hsl(${(i * 7.2 + 40)}, 70%, 50%)`; 

 ย ย ย ย ย ย ย ย ย ย try { 

 ย ย ย ย ย ย ย ย ย ย ย ย // This inserts the rule into the stylesheet for performance 

 ย ย ย ย ย ย ย ย ย ย ย ย styleSheet.insertRule(`[data-back-style="${back.id}"] .face-down { background: linear-gradient(45deg, ${color1}, ${color2}); }`, styleSheet.cssRules.length); 

 ย ย ย ย ย ย ย ย ย ย } catch(e) { /* Rule might already exist, so we ignore the error */ } 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย }); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย if(winCountEl) winCountEl.textContent = winCount; 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย // Populate the options modal with card back choices 

 ย ย ย ย ย ย cardBackSelector.innerHTML = ''; 

 ย ย ย ย ย ย SHUFFLED_CARD_BACKS.forEach((back) => { 

 ย ย ย ย ย ย ย ย const option = document.createElement('div'); 

 ย ย ย ย ย ย ย ย option.className = 'options-grid-item'; 

 ย ย ย ย ย ย ย ย option.dataset.backStyle = back.id; // Use the same data attribute for styling the preview 

 ย ย ย ย ย ย ย ยย 

 ย ย ย ย ย ย ย ย if (unlockedBacks.includes(back.id)) { 

 ย ย ย ย ย ย ย ย ย ย if (back.id === selectedBack) option.classList.add('selected'); 

 ย ย ย ย ย ย ย ย ย ย option.addEventListener('click', () => { 

 ย ย ย ย ย ย ย ย ย ย ย ย selectedBack = back.id; 

 ย ย ย ย ย ย ย ย ย ย ย ย sounds.click.triggerAttackRelease("C3", "8n"); 

 ย ย ย ย ย ย ย ย ย ย ย ย updateCardStyles(); 

 ย ย ย ย ย ย ย ย ย ย ย ย saveProgress(); 

 ย ย ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย ย ย option.classList.add('locked'); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย cardBackSelector.appendChild(option); 

 ย ย ย ย ย ย }); 

 ย ย ย ย ย ย // Apply the generated styles to the option previews 

 ย ย ย ย ย ย document.querySelectorAll('#card-back-selector .options-grid-item').forEach(el => { 

 ย ย ย ย ย ย ย ย const backId = el.dataset.backStyle; 

 ย ย ย ย ย ย ย ย const backData = CARD_BACKS.find(b => b.id === backId); 

 ย ย ย ย ย ย ย ย if (backData && backData.type === 'procedural') { 

 ย ย ย ย ย ย ย ย ย ย const i = parseInt(backId.split('-')[1]); 

 ย ย ย ย ย ย ย ย ย ย const color1 = `hsl(${i * 7.2}, 70%, 50%)`; 

 ย ย ย ย ย ย ย ย ย ย const color2 = `hsl(${(i * 7.2 + 40)}, 70%, 50%)`; 

 ย ย ย ย ย ย ย ย ย ย el.style.background = `linear-gradient(45deg, ${color1}, ${color2})`; 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย }); 





 ย ย ย ย ย ย // Populate the options modal with board choices 

 ย ย ย ย ย ย boardSelector.innerHTML = ''; 

 ย ย ย ย ย ย BOARD_DATA.forEach((boardData) => { 

 ย ย ย ย ย ย ย ย const option = document.createElement('div'); 

 ย ย ย ย ย ย ย ย option.className = 'options-grid-item'; 

 ย ย ย ย ย ย ย ย option.dataset.tempBoard = boardData.id; 

 ย ย ย ย ย ย ย ย if (unlockedBoards.includes(boardData.id)) { 

 ย ย ย ย ย ย ย ย ย ย if (boardData.id === selectedBoard) option.classList.add('selected'); 

 ย ย ย ย ย ย ย ย ย ย option.addEventListener('click', () => { 

 ย ย ย ย ย ย ย ย ย ย ย ย // --- DEV UNLOCK CODE --- 

 ย ย ย ย ย ย ย ย ย ย ย ย if (boardData.id === 'board-0') { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย devUnlockCounter++; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย if (devUnlockCounter >= 8) { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย unlockEverything(); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย devUnlockCounter = 0; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย devUnlockCounter = 0; // Reset counter if another board is clicked 

 ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย ย ย // --- END DEV UNLOCK --- 



 ย ย ย ย ย ย ย ย ย ย ย ย selectedBoard = boardData.id; 

 ย ย ย ย ย ย ย ย ย ย ย ย sounds.click.triggerAttackRelease("C3", "8n"); 

 ย ย ย ย ย ย ย ย ย ย ย ย updateCardStyles(); 

 ย ย ย ย ย ย ย ย ย ย ย ย saveProgress(); 

 ย ย ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย ย ย option.classList.add('locked'); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย boardSelector.appendChild(option); 

 ย ย ย ย ย ย }); 

 ย ย ย ย ย ย // Apply preview styles to the board options 

 ย ย ย ย ย ย document.querySelectorAll('[data-temp-board]').forEach(el => { 

 ย ย ย ย ย ย ย ย const boardId = el.dataset.tempBoard; 

 ย ย ย ย ย ย ย ย const i = BOARD_DATA.findIndex(b => b.id === boardId); 

 ย ย ย ย ย ย ย ย const boardData = BOARD_DATA[i]; 

 ย ย ย ย ย ย ย ย const previews = { 

 ย ย ย ย ย ย ย ย ย ย 'board-1': { bg: 'linear-gradient(45deg, #3a1c71, #d76d77, #ffaf7b)', icon: '๐ง' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-2': { bg: 'black', icon: 'โจ' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-3': { bg: '#001f3f', icon: '๐' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-4': { bg: 'black', icon: 'ใข', color: '#0F0' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-5': { bg: '#14141e', icon: '๐' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-6': { bg: 'black', icon: '๐ฅ' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-7': { bg: '#001428', icon: '๐ง' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-8': { bg: 'black', icon: '๐' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-9': { bg: 'linear-gradient(45deg, #ff00ff, #00ffff)', icon: '๐' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-10': { bg: 'linear-gradient(#2a4a2a, #0a1a0a)', icon: '๐ฒ' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-11': { bg: 'black', icon: '๐', color: '#0FF' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-12': { bg: '#FFC0CB', icon: '๐ธ', color: '#FFF' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-13': { bg: '#111', icon: 'โจ', color: '#AAA' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-14': { bg: 'black', icon: 'โฆ', color: '#0FF' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-15': { bg: 'hsl(40, 50%, 70%)', icon: '๐๏ธ' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-16': { bg: '#F5EEDC', icon: 'โ๏ธ', color: 'black' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-17': { bg: 'black', icon: '๐ซ' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-18': { bg: 'black', icon: '๐ต', color: 'magenta' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-19': { bg: '#0a1a0a', icon: '๐', color: 'cyan' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-20': { bg: 'black', icon: '๐', color: 'white' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-21': { bg: '#3498db', icon: '๐ง' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-22': { bg: 'black', icon: 'โจ' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-23': { bg: 'black', icon: ' glitch ' , color: '#f0f'}, 

 ย ย ย ย ย ย ย ย ย ย 'board-24': { bg: '#111', icon: '๐' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-25': { bg: 'black', icon: 'โญ' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-26': { bg: '#21003c', icon: '๐', color: '#ff00ff' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-27': { bg: '#000010', icon: 'โ๏ธ' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-28': { bg: '#0c2e12', icon: '๐ฟ', color: '#3a5f0b' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-29': { bg: '#0a0a1a', icon: '๐๏ธ', color: '#ffffaa' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-30': { bg: '#f0f0f0', icon: '๐จ' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-31': { bg: '#00001a', icon: '๐', color: '#ff00ff' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-32': { bg: '#10002b', icon: '๐ด', color: '#00ffff' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-33': { bg: '#f0f0f0', icon: '๐', color: '#e91e63' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-34': { bg: '#444', icon: '๐ผ', color: '#fff' }, 

 ย ย ย ย ย ย ย ย ย ย 'board-35': { bg: '#000022', icon: '๐พ', color: '#ffff00' }, 

 ย ย ย ย ย ย ย ย }; 

 ย ย ย ย ย ย ย ย if (previews[boardId]) { 

 ย ย ย ย ย ย ย ย ย ย el.style.background = previews[boardId].bg; 

 ย ย ย ย ย ย ย ย ย ย el.style.backgroundImage = 'none'; 

 ย ย ย ย ย ย ย ย ย ย el.innerHTML = `<span style="font-size: 40px; line-height: 140px; text-align: center; display: block; color: ${previews[boardId].color || 'white'};">${previews[boardId].icon}</span>`; 

 ย ย ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย ย ย const color = `hsl(${i * 7.2}, 50%, 20%)`; 

 ย ย ย ย ย ย ย ย ย ย el.style.backgroundColor = color; 

 ย ย ย ย ย ย ย ย ย ย el.style.backgroundImage = `linear-gradient(45deg, rgba(0,0,0,0.1) 25%, transparent 25%), linear-gradient(-45deg, rgba(0,0,0,0.1) 25%, transparent 25%)`; 

 ย ย ย ย ย ย ย ย ย ย el.innerHTML = ''; 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย }); 



 ย ย ย ย ย ย // Populate the music options grid 

 ย ย ย ย ย ย musicSelector.innerHTML = ''; 

 ย ย ย ย ย ย MUSIC_DATA.forEach((trackData) => { 

 ย ย ย ย ย ย ย ย const option = document.createElement('div'); 

 ย ย ย ย ย ย ย ย option.className = 'options-grid-item'; 

 ย ย ย ย ย ย ย ย option.style.cssText = `display: flex; align-items: center; justify-content: center; flex-direction: column; font-size: 12px; padding: 10px; box-sizing: border-box; text-align: center; background-color: #333; color: white;`; 



 ย ย ย ย ย ย ย ย if (unlockedTracks.includes(trackData.id)) { 

 ย ย ย ย ย ย ย ย ย ย option.innerHTML = `<span style="font-size: 40px;">๐ต</span><span>${trackData.name}</span>`; 

 ย ย ย ย ย ย ย ย ย ย option.title = `Unlocked: ${trackData.name}`; 

 ย ย ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย ย ย option.classList.add('locked'); 

 ย ย ย ย ย ย ย ย ย ย option.innerHTML = `<span>${trackData.name}</span>`; 

 ย ย ย ย ย ย ย ย ย ย option.title = 'Locked'; 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย musicSelector.appendChild(option); 

 ย ย ย ย ย ย }); 

 ย ย ย ย } 

 ย ย ย ยย 

 ย ย ย ย // --- Core Game Logic --- 

 ย ย ย ย function createDeck() { return SUITS.flatMap(suit => VALUES.map((value, index) => ({ suit, value, rank: index + 1, color: (suit === 'โฅ' || suit === 'โฆ') ? 'red' : 'black', isFaceUp: false, id: `${value}-${suit}` }))); } 

 ย ย ย ย function shuffleDeck(deck) { for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; } } 

 ย ย ย ย function dealCards(deck) { for (let i = 0; i < 7; i++) { for (let j = i; j < 7; j++) tableau[j].push(deck.pop()); } tableau.forEach(pile => { if (pile.length > 0) pile[pile.length - 1].isFaceUp = true; }); stock = deck; } 

 ย ย ย ยย 

 ย ย ย ย /** 

 ย ย ย ย ย* Main rendering function. Calls sub-render functions and checks for win/autocomplete conditions. 

 ย ย ย ย ย*/ 

 ย ย ย ย function render() { 

 ย ย ย ย ย ย if (isGameWon) return; 

 ย ย ย ย ย ย renderStockAndWaste(); 

 ย ย ย ย ย ย renderFoundations(); 

 ย ย ย ย ย ย renderTableau(); 

 ย ย ย ย ย ย checkWinCondition(); 

 ย ย ย ย ย ย checkAutocomplete(); 

 ย ย ย ย } 



 ย ย ย ย function renderStockAndWaste() { 

 ย ย ย ย ย ย stockPileEl.innerHTML = ''; 

 ย ย ย ย ย ย wastePileEl.innerHTML = ''; 

 ย ย ย ย ย ย if (stock.length > 0) stockPileEl.appendChild(createCardElement(stock[stock.length - 1])); 

 ย ย ย ย ย ย if (waste.length > 0) { 

 ย ย ย ย ย ย ย ย const showCount = drawCount === 1 ? 1 : 3; 

 ย ย ย ย ย ย ย ย const cardsToShow = waste.slice(-showCount); 

 ย ย ย ย ย ย ย ย cardsToShow.forEach((card, i) => { 

 ย ย ย ย ย ย ย ย ย ย card.isFaceUp = true; 

 ย ย ย ย ย ย ย ย ย ย const isTop = i === cardsToShow.length - 1; 

 ย ย ย ย ย ย ย ย ย ย const cardEl = createCardElement(card, isTop); 

 ย ย ย ย ย ย ย ย ย ย cardEl.style.left = `${i * 20}px`; // Stagger waste pile cards 

 ย ย ย ย ย ย ย ย ย ย cardEl.style.zIndex = i; 

 ย ย ย ย ย ย ย ย ย ย if (!isTop) { 

 ย ย ย ย ย ย ย ย ย ย ย ย cardEl.style.pointerEvents = 'none'; // Only top card is interactive 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย wastePileEl.appendChild(cardEl); 

 ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย } 

 ย ย ย ย } 

 ย ย ย ย function renderFoundations() { 

 ย ย ย ย ย ย foundationEls.forEach((foundationEl, index) => { 

 ย ย ย ย ย ย ย ย foundationEl.innerHTML = ''; 

 ย ย ย ย ย ย ย ย const pile = foundations[index]; 

 ย ย ย ย ย ย ย ย if (pile.length > 0) { 

 ย ย ย ย ย ย ย ย ย ย foundationEl.appendChild(createCardElement(pile[pile.length - 1], true)); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย }); 

 ย ย ย ย } 

 ย ย ย ยย 

 ย ย ย ย function renderTableau() { 

 ย ย ย ย ย ย tableauEls.forEach((tableauEl, pileIndex) => { 

 ย ย ย ย ย ย ย ย tableauEl.innerHTML = ''; 

 ย ย ย ย ย ย ย ย const pile = tableau[pileIndex]; 

 ย ย ย ย ย ย ย ย if (pile.length === 0) { 

 ย ย ย ย ย ย ย ย ย ย // Add a placeholder element to allow dropping Kings on empty piles 

 ย ย ย ย ย ย ย ย ย ย const placeholder = document.createElement('div'); 

 ย ย ย ย ย ย ย ย ย ย placeholder.className = 'pile'; 

 ย ย ย ย ย ย ย ย ย ย placeholder.style.position = 'static'; 

 ย ย ย ย ย ย ย ย ย ย tableauEl.appendChild(placeholder); 

 ย ย ย ย ย ย ย ย ย ย tableauEl.style.minHeight = `var(--card-height)`; // Reset height 

 ย ย ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย ย ย pile.forEach((card, cardIndex) => { 

 ย ย ย ย ย ย ย ย ย ย ย ย const isTop = cardIndex === pile.length - 1; 

 ย ย ย ย ย ย ย ย ย ย ย ย const cardEl = createCardElement(card, isTop); 

 ย ย ย ย ย ย ย ย ย ย ย ย cardEl.style.top = `${cardIndex * CARD_OVERLAP}px`; 

 ย ย ย ย ย ย ย ย ย ย ย ย tableauEl.appendChild(cardEl); 

 ย ย ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย ย ย ย ย // Adjust the height of the pile container to accommodate all cards 

 ย ย ย ย ย ย ย ย ย ย const cardHeight = varToNum('--card-height'); 

 ย ย ย ย ย ย ย ย ย ย const newHeight = cardHeight + (pile.length > 1 ? (pile.length - 1) * CARD_OVERLAP : 0); 

 ย ย ย ย ย ย ย ย ย ย tableauEl.style.minHeight = `${newHeight}px`; 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย }); 

 ย ย ย ย } 

 ย ย ย ยย 

 ย ย ย ย /** 

 ย ย ย ย ย* Creates a DOM element for a given card object. 

 ย ย ย ย ย* @param {object} card - The card data object. 

 ย ย ย ย ย* @param {boolean} isTopCard - Whether this card is at the top of its stack. 

 ย ย ย ย ย* @returns {HTMLElement} The created card element. 

 ย ย ย ย ย*/ 

 ย ย ย ย function createCardElement(card, isTopCard = false) { 

 ย ย ย ย ย ย const cardEl = document.createElement('div'); 

 ย ย ย ย ย ย cardEl.className = `card ${card.color}`; 

 ย ย ย ย ย ย if (isTopCard) cardEl.classList.add('is-top-card'); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย cardEl.dataset.cardId = card.id; 

 ย ย ย ย ย ย if (card.isFaceUp) { 

 ย ย ย ย ย ย ย ย cardEl.innerHTML = `<div class="card-value top">${card.value}${card.suit}</div><div class="card-center-suit">${card.suit}<div class="card-center-value">${card.value}</div></div><div class="card-value bottom">${card.value}${card.suit}</div>`; 

 ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย cardEl.classList.add('face-down'); 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย return cardEl; 

 ย ย ย ย } 



 ย ย ย ย // --- Event Handlers --- 

 ย ย ย ย newGameBtn.addEventListener('click', () => { sounds.click.triggerAttackRelease("C2", "8n"); promptNewGame(); }); 

 ย ย ย ย draw1Btn.addEventListener('click', () => { 

 ย ย ย ย ย ย drawCount = 1; 

 ย ย ย ย ย ย drawSelectModal.style.display = 'none'; 

 ย ย ย ย ย ย cardStyleModal.style.display = 'flex'; 

 ย ย ย ย }); 

 ย ย ย ย draw3Btn.addEventListener('click', () => { 

 ย ย ย ย ย ย drawCount = 3; 

 ย ย ย ย ย ย drawSelectModal.style.display = 'none'; 

 ย ย ย ย ย ย cardStyleModal.style.display = 'flex'; 

 ย ย ย ย }); 

 ย ย ย ย normalStyleBtn.addEventListener('click', () => { 

 ย ย ย ย ย ย faceStyle = 'default'; 

 ย ย ย ย ย ย cardStyleModal.style.display = 'none'; 

 ย ย ย ย ย ย initializeNewGame(); 

 ย ย ย ย }); 

 ย ย ย ย easySeeBtn.addEventListener('click', () => { 

 ย ย ย ย ย ย faceStyle = 'easy-see'; 

 ย ย ย ย ย ย cardStyleModal.style.display = 'none'; 

 ย ย ย ย ย ย initializeNewGame(); 

 ย ย ย ย }); 



 ย ย ย ย autocompleteBtn.addEventListener('click', runAutocomplete); 

 ย ย ย ย hintBtn.addEventListener('click', () => { findHint(); }); 

 ย ย ย ย undoBtn.addEventListener('click', undoMove); 

 ย ย ย ย optionsBtn.addEventListener('click', () => { sounds.click.triggerAttackRelease("C3", "8n"); optionsModal.style.display = 'flex'; updateCardStyles(); }); 

 ย ย ย ย closeModalBtn.addEventListener('click', () => { optionsModal.style.display = 'none'; }); 

 ย ย ย ยย 

 ย ย ย ย unlockCloseBtn.addEventListener('click', () => { 

 ย ย ย ย ย ย unlockModal.style.display = 'none'; 

 ย ย ย ย ย ย isPopupVisible = false; 

 ย ย ย ย ย ย showNextUnlockPopup(); 

 ย ย ย ย }); 



 ย ย ย ย unlockApplyBtn.addEventListener('click', () => { 

 ย ย ย ย ย ย if (currentApplyCallback) { 

 ย ย ย ย ย ย ย ย currentApplyCallback(); 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย unlockModal.style.display = 'none'; 

 ย ย ย ย ย ย isPopupVisible = false; 

 ย ย ย ย ย ย showNextUnlockPopup(); 

 ย ย ย ย }); 



 ย ย ย ย window.addEventListener('click', (e) => { 

 ย ย ย ย ย ย if (e.target == optionsModal) { 

 ย ย ย ย ย ย ย ย optionsModal.style.display = 'none'; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย if (e.target == achievementModal) { 

 ย ย ย ย ย ย ย ย achievementModal.style.display = 'none'; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย if (e.target == unlockModal) { 

 ย ย ย ย ย ย ย ย unlockModal.style.display = 'none'; 

 ย ย ย ย ย ย ย ย isPopupVisible = false; 

 ย ย ย ย ย ย ย ย showNextUnlockPopup(); 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย ยif (e.target == resetConfirmModal) { 

 ย ย ย ย ย ย ย ย resetConfirmModal.style.display = 'none'; 

 ย ย ย ย ย ย } 

 ย ย ย ย }); 



 ย ย ย ย achievementsBtn.addEventListener('click', () => { 

 ย ย ย ย ย ย renderAchievementList(); 

 ย ย ย ย ย ย achievementModal.style.display = 'flex'; 

 ย ย ย ย }); 

 ย ย ย ย closeAchievementModalBtn.addEventListener('click', () => { 

 ย ย ย ย ย ย achievementModal.style.display = 'none'; 

 ย ย ย ย }); 



 ย ย ย ย stockPileEl.addEventListener('click', () => { 

 ย ย ย ย ย ย const now = Date.now(); 

 ย ย ย ย ย ย if (now - lastStockClickTime < 200) return; // Debounce clicks 

 ย ย ย ย ย ย lastStockClickTime = now; 

 ย ย ย ย ย ย saveState(); // Save state before the move 

 ย ย ย ย ย ย if (stock.length > 0) { 

 ย ย ย ย ย ย ย ย const numToDraw = Math.min(stock.length, drawCount); 

 ย ย ย ย ย ย ย ย for (let i = 0; i < numToDraw; i++) waste.push(stock.pop()); 

 ย ย ย ย ย ย } else if (waste.length > 0) { 

 ย ย ย ย ย ย ย ย // Recycle waste pile back to stock 

 ย ย ย ย ย ย ย ย stock = waste.map(card => ({ ...card, isFaceUp: false })).reverse(); 

 ย ย ย ย ย ย ย ย waste = []; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย render(); 

 ย ย ย ย }); 



 ย ย ย ย // --- Drag and Drop (Mouse & Touch) --- 

 ย ย ย ย /** 

 ย ย ย ย ย* Creates a proxy element that follows the cursor during a drag operation. 

 ย ย ย ย ย* @param {array} cards - An array of card objects to be included in the proxy. 

 ย ย ย ย ย*/ 

 ย ย ย ย function createDragProxy(cards) { 

 ย ย ย ย ย ย if (dragProxyEl) { 

 ย ย ย ย ย ย ย ย dragProxyEl.remove(); 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย dragProxyEl = document.createElement('div'); 

 ย ย ย ย ย ย dragProxyEl.style.position = 'fixed'; 

 ย ย ย ย ย ย dragProxyEl.style.pointerEvents = 'none'; 

 ย ย ย ย ย ย dragProxyEl.style.zIndex = '2000'; 

 ย ย ย ย ย ย dragProxyEl.style.transform = 'scale(1.05)'; 



 ย ย ย ย ย ย cards.forEach((card, i) => { 

 ย ย ย ย ย ย ย ย const cardEl = createCardElement(card, i === cards.length - 1); 

 ย ย ย ย ย ย ย ย cardEl.style.position = 'absolute'; 

 ย ย ย ย ย ย ย ย cardEl.style.top = `${i * CARD_OVERLAP}px`; 

 ย ย ย ย ย ย ย ย cardEl.style.left = '0'; 

 ย ย ย ย ย ย ย ย dragProxyEl.appendChild(cardEl); 

 ย ย ย ย ย ย }); 



 ย ย ย ย ย ย document.body.appendChild(dragProxyEl); 

 ย ย ย ย } 



 ย ย ย ย /** 

 ย ย ย ย ย* Initiates a drag operation. 

 ย ย ย ย ย* @param {number} clientX - The horizontal coordinate of the pointer. 

 ย ย ย ย ย* @param {number} clientY - The vertical coordinate of the pointer. 

 ย ย ย ย ย* @param {HTMLElement} targetCardEl - The card element where the drag started. 

 ย ย ย ย ย* @returns {boolean} True if the drag was successfully started. 

 ย ย ย ย ย*/ 

 ย ย ย ย function startDrag(clientX, clientY, targetCardEl) { 

 ย ย ย ย ย ย const cardId = targetCardEl.dataset.cardId; 

 ย ย ย ย ย ย const loc = findCardLocation(cardId); 

 ย ย ย ย ย ย // Can't drag from stock or non-top cards in waste 

 ย ย ย ย ย ย if (!loc.pileName || (loc.pileName === 'waste' && loc.cardIndex !== waste.length - 1)) return false; 



 ย ย ย ย ย ย isDragging = true; 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย // Determine which cards are being dragged (a single card or a stack from the tableau) 

 ย ย ย ย ย ย const cardsToDrag = loc.pileName === 'tableau' ? tableau[loc.pileIndex].slice(loc.cardIndex) : [findCard(cardId)]; 

 ย ย ย ย ย ย draggedCardInfo = { cardId, sourcePileName: loc.pileName, sourcePileIndex: loc.pileIndex, sourceCardIndex: loc.cardIndex, draggedCards: cardsToDrag }; 



 ย ย ย ย ย ย const topCardOfStackEl = document.querySelector(`[data-card-id="${cardsToDrag[0].id}"]`); 

 ย ย ย ย ย ย const topCardRect = topCardOfStackEl.getBoundingClientRect(); 



 ย ย ย ย ย ย offsetX = clientX - topCardRect.left; 

 ย ย ย ย ย ย offsetY = clientY - topCardRect.top; 



 ย ย ย ย ย ย createDragProxy(cardsToDrag); 

 ย ย ย ย ย ย moveDrag(clientX, clientY); 



 ย ย ย ย ย ย // Make the original cards semi-transparent 

 ย ย ย ย ย ย cardsToDrag.forEach(c => { 

 ย ย ย ย ย ย ย ย const el = document.querySelector(`[data-card-id="${c.id}"]`); 

 ย ย ย ย ย ย ย ย if (el) el.style.opacity = '0.4'; 

 ย ย ย ย ย ย }); 

 ย ย ย ย ย ย return true; 

 ย ย ย ย } 



 ย ย ย ย /** 

 ย ย ย ย ย* Updates the position of the drag proxy. 

 ย ย ย ย ย*/ 

 ย ย ย ย function moveDrag(clientX, clientY) { 

 ย ย ย ย ย ย if (!isDragging || !dragProxyEl) return; 

 ย ย ย ย ย ย dragProxyEl.style.left = `${clientX - offsetX}px`; 

 ย ย ย ย ย ย dragProxyEl.style.top = `${clientY - offsetY}px`; 

 ย ย ย ย } 



 ย ย ย ย /** 

 ย ย ย ย ย* Ends a drag operation, determines the drop target, and attempts to make a move. 

 ย ย ย ย ย*/ 

 ย ย ย ย function endDrag(clientX, clientY) { 

 ย ย ย ย ย ย if (!isDragging || !draggedCardInfo) { 

 ย ย ย ย ย ย ย ย isDragging = false; 

 ย ย ย ย ย ย ย ย draggedCardInfo = null; 

 ย ย ย ย ย ย ย ย return; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย isDragging = false; 



 ย ย ย ย ย ย // Restore opacity of original cards 

 ย ย ย ย ย ย draggedCardInfo.draggedCards.forEach(c => { 

 ย ย ย ย ย ย ย ย const el = document.querySelector(`[data-card-id="${c.id}"]`); 

 ย ย ย ย ย ย ย ย if (el) el.style.opacity = '1'; 

 ย ย ย ย ย ย }); 



 ย ย ย ย ย ย let dropTargetEl = null; 

 ย ย ย ย ย ย if (dragProxyEl) { 

 ย ย ย ย ย ย ย ย // Temporarily hide the proxy to find the element underneath 

 ย ย ย ย ย ย ย ย dragProxyEl.style.display = 'none'; 

 ย ย ย ย ย ย ย ย dropTargetEl = document.elementFromPoint(clientX, clientY); 

 ย ย ย ย ย ย ย ย dragProxyEl.remove(); 

 ย ย ย ย ย ย ย ย dragProxyEl = null; 

 ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย dropTargetEl = document.elementFromPoint(clientX, clientY); 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย let moveSuccessful = false; 

 ย ย ย ย ย ย const draggedCard = draggedCardInfo.draggedCards[0]; 

 ย ย ย ย ย ย const isAce = draggedCard.rank === 1; 

 ย ย ย ย ย ย const isFoundationAreaDrop = dropTargetEl && dropTargetEl.closest('.foundation-area'); 



 ย ย ย ย ย ย // Case 1: Dragged an Ace and dropped it anywhere on the foundation area 

 ย ย ย ย ย ย if (isAce && isFoundationAreaDrop) { 

 ย ย ย ย ย ย ย ย // Find the first valid foundation pile for this Ace 

 ย ย ย ย ย ย ย ย for (let i = 0; i < foundations.length; i++) { 

 ย ย ย ย ย ย ย ย ย ย if (isValidFoundationMove(draggedCard, i)) { 

 ย ย ย ย ย ย ย ย ย ย ย ย moveSuccessful = handleMove('foundation', i); 

 ย ย ย ย ย ย ย ย ย ย ย ย break; 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } else { // Case 2: Standard drop logic for all other cases 

 ย ย ย ย ย ย ย ย const targetTableauEl = dropTargetEl ? dropTargetEl.closest('.tableau-pile') : null; 

 ย ย ย ย ย ย ย ย const targetFoundationEl = dropTargetEl ? dropTargetEl.closest('.foundation-area .pile') : null; 



 ย ย ย ย ย ย ย ย let targetPileName, targetPileIndex; 



 ย ย ย ย ย ย ย ย if (targetFoundationEl) { 

 ย ย ย ย ย ย ย ย ย ย targetPileName = 'foundation'; 

 ย ย ย ย ย ย ย ย ย ย targetPileIndex = parseInt(targetFoundationEl.id.split('-')[1]); 

 ย ย ย ย ย ย ย ย } else if (targetTableauEl) { 

 ย ย ย ย ย ย ย ย ย ย targetPileName = 'tableau'; 

 ย ย ย ย ย ย ย ย ย ย targetPileIndex = parseInt(targetTableauEl.id.split('-')[1]); 

 ย ย ย ย ย ย ย ย } 



 ย ย ย ย ย ย ย ย if (targetPileName !== undefined) { 

 ย ย ย ย ย ย ย ย ย ย const { sourcePileName, sourcePileIndex } = draggedCardInfo; 

 ย ย ย ย ย ย ย ย ย ย // Prevent penalizing for dropping back on the same pile 

 ย ย ย ย ย ย ย ย ย ย if (targetPileName !== sourcePileName || targetPileIndex !== sourcePileIndex) { 

 ย ย ย ย ย ย ย ย ย ย ย ย ยmoveSuccessful = handleMove(targetPileName, targetPileIndex); 

 ย ย ย ย ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย ย ย ย ย moveSuccessful = true; // Not a real move, but not an error either. 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 



 ย ย ย ย ย ย if (!moveSuccessful && draggedCardInfo) { // Only penalize if a move was attempted 

 ย ย ย ย ย ย ย ย sounds.error.triggerAttackRelease("G2", "8n"); 

 ย ย ย ย ย ย } 



 ย ย ย ย ย ย draggedCardInfo = null; 

 ย ย ย ย ย ย render(); 

 ย ย ย ย } 



 ย ย ย ย // --- MOUSE & TOUCH EVENT BINDING --- 

 ย ย ย ย // This section unifies mouse and touch events to handle clicks, double-clicks, and drags. 

 ย ย ย ย gameBoard.addEventListener('mousedown', (e) => { 

 ย ย ย ย ย ย if (e.button !== 0 || isDragging) return; 

 ย ย ย ย ย ย const cardEl = e.target.closest('.card:not(.face-down)'); 

 ย ย ย ย ย ย if (!cardEl) return; 



 ย ย ย ย ย ย e.preventDefault(); 



 ย ย ย ย ย ย if (Date.now() - lastClickTime < 300) { // Double click detection 

 ย ย ย ย ย ย ย ย clearTimeout(clickTimeout); 

 ย ย ย ย ย ย ย ย lastClickTime = 0; 

 ย ย ย ย ย ย ย ย handleDoubleClick(e.target); 

 ย ย ย ย ย ย } else { // First click 

 ย ย ย ย ย ย ย ย lastClickTime = Date.now(); 

 ย ย ย ย ย ย ย ย mouseDownPos = { x: e.clientX, y: e.clientY, target: cardEl }; 

 ย ย ย ย ย ย } 

 ย ย ย ย }); 



 ย ย ย ย window.addEventListener('mousemove', (e) => { 

 ย ย ย ย ย ย mousePos.x = e.clientX; 

 ย ย ย ย ย ย mousePos.y = e.clientY; 

 ย ย ย ย ย ย if (mouseDownPos && !isDragging) { 

 ย ย ย ย ย ย ย ย const dx = Math.abs(e.clientX - mouseDownPos.x); 

 ย ย ย ย ย ย ย ย const dy = Math.abs(e.clientY - mouseDownPos.y); 

 ย ย ย ย ย ย ย ย if (dx > 5 || dy > 5) { // Drag threshold to prevent accidental drags 

 ย ย ย ย ย ย ย ย ย ย startDrag(mouseDownPos.x, mouseDownPos.y, mouseDownPos.target); 

 ย ย ย ย ย ย ย ย ย ย mouseDownPos = null; 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย if (isDragging) { 

 ย ย ย ย ย ย ย ย e.preventDefault(); 

 ย ย ย ย ย ย ย ย moveDrag(e.clientX, e.clientY); 

 ย ย ย ย ย ย } 

 ย ย ย ย }); 



 ย ย ย ย window.addEventListener('mouseup', (e) => { 

 ย ย ย ย ย ย if (isDragging) { 

 ย ย ย ย ย ย ย ย e.preventDefault(); 

 ย ย ย ย ย ย ย ย endDrag(e.clientX, e.clientY); 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย mouseDownPos = null; 

 ย ย ย ย }); 



 ย ย ย ย // Touch event equivalents 

 ย ย ย ย gameBoard.addEventListener('touchstart', (e) => { 

 ย ย ย ย ย ย const cardEl = e.target.closest('.card:not(.face-down)'); 

 ย ย ย ย ย ย if (!cardEl) return; 

 ย ย ย ย ย ย const touch = e.touches[0]; 

 ย ย ย ย ย ย lastClickTime = Date.now(); 

 ย ย ย ย ย ย mouseDownPos = { x: touch.clientX, y: touch.clientY, target: cardEl }; 

 ย ย ย ย }, { passive: true }); 



 ย ย ย ย gameBoard.addEventListener('touchmove', (e) => { 

 ย ย ย ย ย ย if (e.touches.length > 0) { 

 ย ย ย ย ย ย ย ย mousePos.x = e.touches[0].clientX; 

 ย ย ย ย ย ย ย ย mousePos.y = e.touches[0].clientY; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย if (mouseDownPos && !isDragging) { 

 ย ย ย ย ย ย ย ย const touch = e.touches[0]; 

 ย ย ย ย ย ย ย ย const dx = Math.abs(touch.clientX - mouseDownPos.x); 

 ย ย ย ย ย ย ย ย const dy = Math.abs(touch.clientY - mouseDownPos.y); 

 ย ย ย ย ย ย ย ย if (dx > 10 || dy > 10) { // Larger threshold for touch 

 ย ย ย ย ย ย ย ย ย ย e.preventDefault(); 

 ย ย ย ย ย ย ย ย ย ย startDrag(mouseDownPos.x, mouseDownPos.y, mouseDownPos.target); 

 ย ย ย ย ย ย ย ย ย ย mouseDownPos = null; 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย if (isDragging) { 

 ย ย ย ย ย ย ย ย e.preventDefault(); 

 ย ย ย ย ย ย ย ย moveDrag(e.touches[0].clientX, e.touches[0].clientY); 

 ย ย ย ย ย ย } 

 ย ย ย ย }, { passive: false }); 



 ย ย ย ย gameBoard.addEventListener('touchend', (e) => { 

 ย ย ย ย ย ย if (isDragging) { 

 ย ย ย ย ย ย ย ย e.preventDefault(); 

 ย ย ย ย ย ย ย ย endDrag(e.changedTouches[0].clientX, e.changedTouches[0].clientY); 

 ย ย ย ย ย ย } else if (mouseDownPos) { 

 ย ย ย ย ย ย ย ย // Emulate double-click for touch with a quick tap 

 ย ย ย ย ย ย ย ย const timeDiff = Date.now() - lastClickTime; 

 ย ย ย ย ย ย ย ย if (timeDiff < 250) { 

 ย ย ย ย ย ย ย ย ย ย handleDoubleClick(mouseDownPos.target); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย mouseDownPos = null; 

 ย ย ย ย ย ย isDragging = false; 

 ย ย ย ย }); 

 ย ย ย ยย 

 ย ย ย ย // --- Move Logic --- 

 ย ย ย ย /** 

 ย ย ย ย ย* Handles the logic for a completed move, checking for validity and updating the game state. 

 ย ย ย ย ย* @param {string} targetPileName - The name of the destination pile ('foundation' or 'tableau'). 

 ย ย ย ย ย* @param {number} targetPileIndex - The index of the destination pile. 

 ย ย ย ย ย* @returns {boolean} True if a valid move was made. 

 ย ย ย ย ย*/ 

 ย ย ย ย function handleMove(targetPileName, targetPileIndex) { 

 ย ย ย ย ย ย saveState(); 

 ย ย ย ย ย ย triggerAchievement('firstMove'); 

 ย ย ย ย ย ย const { sourcePileName, sourcePileIndex, draggedCards } = draggedCardInfo; 

 ย ย ย ย ย ย const cardToMove = draggedCards[0]; 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย let isValid = false; 

 ย ย ย ย ย ย if (targetPileName === 'foundation' && draggedCards.length === 1 && isValidFoundationMove(cardToMove, targetPileIndex)) { 

 ย ย ย ย ย ย ย ย sounds.foundationPlace.triggerAttackRelease("C5", "8n"); 

 ย ย ย ย ย ย ย ย moveCards(sourcePileName, sourcePileIndex, 'foundation', targetPileIndex, 1); 

 ย ย ย ย ย ย ย ย addXP(1, "+1 XP"); checkAceBonus(); triggerAchievement('firstFoundation'); isValid = true; 

 ย ย ย ย ย ย } else if (targetPileName === 'tableau' && isValidTableauMove(cardToMove, targetPileIndex)) { 

 ย ย ย ย ย ย ย ย if (tableau[targetPileIndex].length === 0 && cardToMove.rank === 13) { 

 ย ย ย ย ย ย ย ย ย ย triggerAchievement('kingMe'); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย sounds.place.triggerAttackRelease("C4", "8n"); 

 ย ย ย ย ย ย ย ย moveCards(sourcePileName, sourcePileIndex, 'tableau', targetPileIndex, draggedCards.length); 

 ย ย ย ย ย ย ย ย checkTableauBonus(targetPileIndex); isValid = true; 

 ย ย ย ย ย ย } 



 ย ย ย ย ย ย if (isValid) { 

 ย ย ย ย ย ย ย ย handleCombo(); 

 ย ย ย ย ย ย ย ย flipSourceTableauCard(sourcePileName, sourcePileIndex); 

 ย ย ย ย ย ย ย ย return true; 

 ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย moveHistory.pop(); // Revert the saved state if move was invalid 

 ย ย ย ย ย ย ย ย return false; 

 ย ย ย ย ย ย } 

 ย ย ย ย } 



 ย ย ย ย function moveCards(fromName, fromIndex, toName, toIndex, numCards) { let sourcePile; if (fromName === 'tableau') sourcePile = tableau[fromIndex]; else if (fromName === 'waste') sourcePile = waste; let targetPile; if (toName === 'tableau') targetPile = tableau[toIndex]; else if (toName === 'foundation') targetPile = foundations[toIndex]; const cards = sourcePile.splice(sourcePile.length - numCards, numCards); targetPile.push(...cards); } 

 ย ย ย ยย 

 ย ย ย ย /** 

 ย ย ย ย ย* Animates a card moving from one pile to another. 

 ย ย ย ย ย* @param {HTMLElement} cardEl - The original card element to animate. 

 ย ย ย ย ย* @param {string} targetId - The ID of the destination pile element. 

 ย ย ย ย ย* @param {function} moveLogic - The function that updates the game state arrays. 

 ย ย ย ย ย*/ 

 ย ย ย ย async function animateAndMoveCard(cardEl, targetId, moveLogic) { 

 ย ย ย ย ย ย gameBoard.style.pointerEvents = 'none'; 

 ย ย ย ย ย ย const startRect = cardEl.getBoundingClientRect(); 

 ย ย ย ย ย ย const clone = cardEl.cloneNode(true); 

 ย ย ย ย ย ย clone.style.cssText = `position: fixed; left: ${startRect.left}px; top: ${startRect.top}px; z-index: 2000; margin: 0;`; 

 ย ย ย ย ย ย document.body.appendChild(clone); 

 ย ย ย ย ย ย cardEl.style.opacity = '0'; 



 ย ย ย ย ย ย moveLogic(); 

 ย ย ย ย ย ย render(); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย const newTargetEl = document.getElementById(targetId); 

 ย ย ย ย ย ย if (!newTargetEl) { // Safety check 

 ย ย ย ย ย ย ย ย document.body.removeChild(clone); 

 ย ย ย ย ย ย ย ย render(); 

 ย ย ย ย ย ย ย ย gameBoard.style.pointerEvents = 'auto'; 

 ย ย ย ย ย ย ย ย return; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย const topCardEl = newTargetEl.querySelector('.card:last-child') || newTargetEl; 

 ย ย ย ย ย ย const endRect = topCardEl.getBoundingClientRect(); 

 ย ย ย ย ย ย const deltaX = endRect.left - startRect.left; 

 ย ย ย ย ย ย const deltaY = endRect.top - startRect.top; 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย await new Promise(resolve => requestAnimationFrame(() => { 

 ย ย ย ย ย ย ย ย clone.style.transition = 'transform 0.25s ease-in-out'; 

 ย ย ย ย ย ย ย ย clone.style.transform = `translate(${deltaX}px, ${deltaY}px)`; 

 ย ย ย ย ย ย ย ย resolve(); 

 ย ย ย ย ย ย })); 

 ย ย ย ย ย ย await new Promise(resolve => setTimeout(resolve, 250)); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย document.body.removeChild(clone); 

 ย ย ย ย ย ย render(); 

 ย ย ย ย ย ย gameBoard.style.pointerEvents = 'auto'; 

 ย ย ย ย } 

 ย ย ย ยย 

 ย ย ย ย /** 

 ย ย ย ย ย* Handles auto-moving a card on double-click/tap. 

 ย ย ย ย ย* @param {HTMLElement} target - The element that was double-clicked. 

 ย ย ย ย ย*/ 

 ย ย ย ย async function handleDoubleClick(target) { 

 ย ย ย ย ย ย if (playerLevel < 2) { 

 ย ย ย ย ย ย ย ย messageBox.textContent = 'Unlock Auto-Move at Level 2!'; 

 ย ย ย ย ย ย ย ย setTimeout(() => messageBox.textContent = '', 2000); 

 ย ย ย ย ย ย ย ย return; 

 ย ย ย ย ย ย } 



 ย ย ย ย ย ย const cardEl = target.closest('.card'); 

 ย ย ย ย ย ย if (!cardEl || cardEl.classList.contains('face-down')) return; 



 ย ย ย ย ย ย const cardId = cardEl.dataset.cardId; 

 ย ย ย ย ย ย const loc = findCardLocation(cardId); 

 ย ย ย ย ย ย if (!loc.pileName) return; 



 ย ย ย ย ย ย const cardToMove = findCard(cardId); 

 ย ย ย ย ย ย if (!cardToMove) return; 



 ย ย ย ย ย ย const isTopCard = (loc.pileName === 'waste' && loc.cardIndex === waste.length - 1) || 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย (loc.pileName === 'tableau' && loc.cardIndex === tableau[loc.pileIndex].length - 1); 



 ย ย ย ย ย ย // Priority 1: Move to a valid foundation. 

 ย ย ย ย ย ย if (isTopCard) { 

 ย ย ย ย ย ย ย ย for (let i = 0; i < foundations.length; i++) { 

 ย ย ย ย ย ย ย ย ย ย if (isValidFoundationMove(cardToMove, i)) { 

 ย ย ย ย ย ย ย ย ย ย ย ย saveState(); 

 ย ย ย ย ย ย ย ย ย ย ย ย triggerAchievement('firstMove'); 

 ย ย ย ย ย ย ย ย ย ย ย ย const targetId = foundationEls[i].id; 

 ย ย ย ย ย ย ย ย ย ย ย ย const moveFn = () => { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย moveCards(loc.pileName, loc.pileIndex, 'foundation', i, 1); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย flipSourceTableauCard(loc.pileName, loc.pileIndex); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย addXP(1, "+1 XP"); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย checkAceBonus(); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย triggerAchievement('firstFoundation'); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย handleCombo(); 

 ย ย ย ย ย ย ย ย ย ย ย ย }; 

 ย ย ย ย ย ย ย ย ย ย ย ย sounds.foundationPlace.triggerAttackRelease("C5", "8n"); 

 ย ย ย ย ย ย ย ย ย ย ย ย await animateAndMoveCard(cardEl, targetId, moveFn); 

 ย ย ย ย ย ย ย ย ย ย ย ย return; 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย const cardsToMove = (loc.pileName === 'tableau') ? tableau[loc.pileIndex].slice(loc.cardIndex) : [cardToMove]; 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย // Priority 2: Move a King stack to an empty tableau spot. 

 ย ย ย ย ย ย if (cardsToMove[0].rank === 13) { 

 ย ย ย ย ย ย ย ย for (let i = 0; i < tableau.length; i++) { 

 ย ย ย ย ย ย ย ย ย ย if (tableau[i].length === 0) { 

 ย ย ย ย ย ย ย ย ย ย ย ย saveState(); 

 ย ย ย ย ย ย ย ย ย ย ย ย triggerAchievement('firstMove'); 

 ย ย ย ย ย ย ย ย ย ย ย ย triggerAchievement('kingMe'); 

 ย ย ย ย ย ย ย ย ย ย ย ย const targetId = tableauEls[i].id; 

 ย ย ย ย ย ย ย ย ย ย ย ย const moveFn = () => { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย moveCards(loc.pileName, loc.pileIndex, 'tableau', i, cardsToMove.length); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย flipSourceTableauCard(loc.pileName, loc.pileIndex); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย handleCombo(); 

 ย ย ย ย ย ย ย ย ย ย ย ย }; 

 ย ย ย ย ย ย ย ย ย ย ย ย sounds.place.triggerAttackRelease("C4", "8n"); 

 ย ย ย ย ย ย ย ย ย ย ย ย await animateAndMoveCard(cardEl, targetId, moveFn); 

 ย ย ย ย ย ย ย ย ย ย ย ย return; 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย // Priority 3: Move a stack to another valid tableau pile. 

 ย ย ย ย ย ย if (isTopCard || loc.pileName === 'tableau') { 

 ย ย ย ย ย ย ย ย for (let i = 0; i < tableau.length; i++) { 

 ย ย ย ย ย ย ย ย ย ย if (loc.pileName === 'tableau' && i === loc.pileIndex) continue; 

 ย ย ย ย ย ย ย ย ย ย if (isValidTableauMove(cardsToMove[0], i)) { 

 ย ย ย ย ย ย ย ย ย ย ย ย saveState(); 

 ย ย ย ย ย ย ย ย ย ย ย ย triggerAchievement('firstMove'); 

 ย ย ย ย ย ย ย ย ย ย ย ย const targetId = tableauEls[i].id; 

 ย ย ย ย ย ย ย ย ย ย ย ย const moveFn = () => { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย moveCards(loc.pileName, loc.pileIndex, 'tableau', i, cardsToMove.length); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย flipSourceTableauCard(loc.pileName, loc.pileIndex); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย checkTableauBonus(i); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย handleCombo(); 

 ย ย ย ย ย ย ย ย ย ย ย ย }; 

 ย ย ย ย ย ย ย ย ย ย ย ย sounds.place.triggerAttackRelease("C4", "8n"); 

 ย ย ย ย ย ย ย ย ย ย ย ย await animateAndMoveCard(cardEl, targetId, moveFn); 

 ย ย ย ย ย ย ย ย ย ย ย ย return; 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 



 ย ย ย ย ย ย sounds.error.triggerAttackRelease("G2", "8n"); 

 ย ย ย ย } 

 ย ย ย ย function isValidFoundationMove(card, foundationIndex) { 

 ย ย ย ย ย ย const foundationPile = foundations[foundationIndex]; 



 ย ย ย ย ย ย if (foundationPile.length === 0) { 

 ย ย ย ย ย ย ย ย const suitAlreadyPlaced = foundations.some(pile => pile.length > 0 && pile[0].suit === card.suit); 

 ย ย ย ย ย ย ย ย return card.rank === 1 && !suitAlreadyPlaced; 

 ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย const topCard = foundationPile[foundationPile.length - 1]; 

 ย ย ย ย ย ย ย ย return card.suit === topCard.suit && card.rank === topCard.rank + 1; 

 ย ย ย ย ย ย } 

 ย ย ย ย } 

 ย ย ย ย function isValidTableauMove(card, tableauIndex) { const tableauPile = tableau[tableauIndex]; if (tableauPile.length === 0) return card.rank === 13; const topCard = tableauPile[tableauPile.length - 1]; return card.rank === topCard.rank - 1 && card.color !== topCard.color; } 

 ย ย ย ยย 

 ย ย ย ย // --- Helper & Utility Functions --- 

 ย ย ย ย function flipSourceTableauCard(sourcePileName, sourcePileIndex) { if (sourcePileName === 'tableau') { const sourcePile = tableau[sourcePileIndex]; if (sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].isFaceUp) { sourcePile[sourcePile.length - 1].isFaceUp = true; } } } 

 ย ย ย ย function findCard(cardId) { for (const pile of [stock, waste, ...foundations, ...tableau]) { for (const card of pile) { if (card.id === cardId) return card; } } return null; } 

 ย ย ย ย function findCardLocation(cardId) { if (waste.length > 0 && waste[waste.length - 1].id === cardId) return { pileName: 'waste', pileIndex: -1, cardIndex: waste.length - 1 }; for (let i = 0; i < foundations.length; i++) { const p = foundations[i]; if (p.length > 0 && p[p.length - 1].id === cardId) return { pileName: 'foundation', pileIndex: i, cardIndex: p.length - 1 }; } for (let i = 0; i < tableau.length; i++) { const p = tableau[i]; for (let j = 0; j < p.length; j++) if (p[j].id === cardId) return { pileName: 'tableau', pileIndex: i, cardIndex: j }; } return {}; } 

 ย ย ย ยย 

 ย ย ย ย // --- Combo System --- 

 ย ย ย ย function handleCombo() { 

 ย ย ย ย ย ย const now = Date.now(); 

 ย ย ย ย ย ย if (now - lastMoveTime < 4000) { // 4-second window for combos 

 ย ย ย ย ย ย ย ย comboCounter++; 

 ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย comboCounter = 1; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย lastMoveTime = now; 



 ย ย ย ย ย ย clearTimeout(comboTimeout); 

 ย ย ย ย ย ย comboTimeout = setTimeout(resetCombo, 4000); 



 ย ย ย ย ย ย if (comboCounter > 1) { 

 ย ย ย ย ย ย ย ย if (comboCounter === 5) triggerAchievement('combo5'); 

 ย ย ย ย ย ย ย ย const comboText = `${COMBO_WORDS[Math.min(comboCounter - 2, COMBO_WORDS.length - 1)]} x${comboCounter}`; 

 ย ย ย ย ย ย ย ย const comboSize = 40 + (comboCounter * 8); 

 ย ย ย ย ย ย ย ย const comboColor = `hsl(${200 + comboCounter * 10}, 100%, 50%)`; 

 ย ย ย ย ย ย ย ยย 

 ย ย ย ย ย ย ย ย sounds.combo.triggerAttackRelease(100 + comboCounter * 20, "8n"); 

 ย ย ย ย ย ย ย ย spawnComboText(comboText, comboSize, comboColor); 

 ย ย ย ย ย ย } 

 ย ย ย ย } 



 ย ย ย ย function resetCombo() { 

 ย ย ย ย ย ย comboCounter = 0; 

 ย ย ย ย ย ย clearComboText(); 

 ย ย ย ย } 



 ย ย ย ย function spawnComboText(text, size, color) { 

 ย ย ย ย ย ย clearComboText(); 

 ย ย ย ย ย ย const { Bodies, World } = Matter; 

 ย ย ย ย ย ย const letters = text.split(''); 

 ย ย ย ย ย ย const xStart = window.innerWidth / 2 - (letters.length * size / 4); 

 ย ย ย ย ย ย const yStart = window.innerHeight / 3; 



 ย ย ย ย ย ย letters.forEach((letter, i) => { 

 ย ย ย ย ย ย ย ย const body = Bodies.rectangle(xStart + i * size / 2, yStart, size * 0.5, size * 0.5, { 

 ย ย ย ย ย ย ย ย ย ย restitution: 0.8, 

 ย ย ย ย ย ย ย ย ย ย friction: 0.1, 

 ย ย ย ย ย ย ย ย ย ย render: { 

 ย ย ย ย ย ย ย ย ย ย ย ย sprite: { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย texture: createLetterTexture(letter, size, color), 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย xScale: 1, 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย yScale: 1 

 ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย ย ยย 

 ย ย ย ย ย ย ย ย World.add(world, body); 

 ย ย ย ย ย ย ย ย comboBodies.push(body); 



 ย ย ย ย ย ย ย ย // Add a jiggle effect for high combos 

 ย ย ย ย ย ย ย ย if (comboCounter > 5) { 

 ย ย ย ย ย ย ย ย ย ย const vibrate = () => { 

 ย ย ย ย ย ย ย ย ย ย ย ย if (comboBodies.includes(body)) { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย Matter.Body.applyForce(body, body.position, { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย x: (Math.random() - 0.5) * 0.01 * comboCounter, 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย y: (Math.random() - 0.5) * 0.01 * comboCounter 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย requestAnimationFrame(vibrate); 

 ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย }; 

 ย ย ย ย ย ย ย ย ย ย vibrate(); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย }); 

 ย ย ย ย } 



 ย ย ย ย function createLetterTexture(letter, size, color) { 

 ย ย ย ย ย ย const canvas = document.createElement('canvas'); 

 ย ย ย ย ย ย const ctx = canvas.getContext('2d'); 

 ย ย ย ย ย ย canvas.width = size; 

 ย ย ย ย ย ย canvas.height = size; 

 ย ย ย ย ย ย ctx.fillStyle = color; 

 ย ย ย ย ย ย ctx.font = `bold ${size}px 'Segoe UI', sans-serif`; 

 ย ย ย ย ย ย ctx.textAlign = 'center'; 

 ย ย ย ย ย ย ctx.textBaseline = 'middle'; 

 ย ย ย ย ย ย ctx.fillText(letter, size / 2, size / 2); 

 ย ย ย ย ย ย return canvas.toDataURL(); 

 ย ย ย ย } 



 ย ย ย ย function clearComboText() { 

 ย ย ย ย ย ย Matter.World.remove(world, comboBodies); 

 ย ย ย ย ย ย comboBodies = []; 

 ย ย ย ย } 



 ย ย ย ย // --- Progression System --- 

 ย ย ย ย /** 

 ย ย ย ย ย* Unlocks all game content. Triggered by the developer cheat code. 

 ย ย ย ย ย*/ 

 ย ย ย ย function unlockEverything() { 

 ย ย ย ย ย ย playerXP = LEVEL_THRESHOLDS[LEVEL_THRESHOLDS.length - 1]; // Max XP 

 ย ย ย ย ย ย unlockedBacks = SHUFFLED_CARD_BACKS.map(b => b.id); // All card backs 

 ย ย ย ย ย ย unlockedBoards = BOARD_DATA.map(b => b.id); // All boards 

 ย ย ย ย ย ย unlockedAchievements = Object.keys(ACHIEVEMENTS); // All achievements 

 ย ย ย ย ย ย achievementScore = Object.values(ACHIEVEMENTS).reduce((sum, ach) => sum + ach.points, 0); 

 ย ย ย ย ย ย hintsAvailable = 99; 

 ย ย ย ย ย ย undosAvailable = 99; 

 ย ย ย ย ย ย unlockedTracks = MUSIC_DATA.map(t => t.id); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย checkLevelUp(false); // Update to max level silently 

 ย ย ย ย ย ย updateCardStyles(); // Refresh options UI 

 ย ย ย ย ย ย updatePlayerStatsUI(); 

 ย ย ย ย ย ย saveProgress(); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย sounds.levelUp.triggerAttackRelease("C7", "2n"); 

 ย ย ย ย ย ย queueUnlockPopup("๐ Dev Mode Activated ๐", "Everything has been unlocked. Enjoy!"); 

 ย ย ย ย } 



 ย ย ย ย function addXP(amount, reason = '') { 

 ย ย ย ย ย ย if (reason) { 

 ย ย ย ย ย ย ย ย const currentMsg = messageBox.textContent; 

 ย ย ย ย ย ย ย ย messageBox.textContent = reason; 

 ย ย ย ย ย ย ย ย setTimeout(() => { 

 ย ย ย ย ย ย ย ย ย ย if (messageBox.textContent === reason) { 

 ย ย ย ย ย ย ย ย ย ย ย ย messageBox.textContent = ''; 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย }, 2000); 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย playerXP += amount; 

 ย ย ย ย ย ย checkLevelUp(true); 

 ย ย ย ย ย ย updatePlayerStatsUI(); 

 ย ย ย ย ย ย saveProgress(); 

 ย ย ย ย } 



 ย ย ย ย function queueUnlockPopup(title, description, applyCallback = null) { 

 ย ย ย ย ย ย unlockPopupQueue.push({ title, description, applyCallback }); 

 ย ย ย ย ย ย showNextUnlockPopup(); 

 ย ย ย ย } 



 ย ย ย ย function showNextUnlockPopup() { 

 ย ย ย ย ย ย if (isPopupVisible || unlockPopupQueue.length === 0) { 

 ย ย ย ย ย ย ย ย return; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย isPopupVisible = true; 

 ย ย ย ยย 

 ย ย ย ย ย ย const { title, description, applyCallback } = unlockPopupQueue.shift(); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย unlockTitle.textContent = title; 

 ย ย ย ย ย ย unlockDescription.innerHTML = description; 

 ย ย ย ย ย ย currentApplyCallback = applyCallback; 

 ย ย ย ยย 

 ย ย ย ย ย ย if (applyCallback) { 

 ย ย ย ย ย ย ย ย unlockPrompt.style.display = 'block'; 

 ย ย ย ย ย ย ย ย unlockApplyBtn.style.display = 'inline-block'; 

 ย ย ย ย ย ย ย ย unlockCloseBtn.textContent = 'No, Thanks'; 

 ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย unlockPrompt.style.display = 'none'; 

 ย ย ย ย ย ย ย ย unlockApplyBtn.style.display = 'none'; 

 ย ย ย ย ย ย ย ย unlockCloseBtn.textContent = 'Awesome!'; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย unlockModal.style.display = 'flex'; 

 ย ย ย ย } 



 ย ย ย ย function checkLevelUp(showNotification) { 

 ย ย ย ย ย ย const oldLevel = playerLevel; 

 ย ย ย ย ย ย let newLevel = 1; 

 ย ย ย ย ย ย for (let i = 0; i < LEVEL_THRESHOLDS.length; i++) { 

 ย ย ย ย ย ย ย ย if (playerXP >= LEVEL_THRESHOLDS[i]) { 

 ย ย ย ย ย ย ย ย ย ย newLevel = i + 1; 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย if (newLevel > playerLevel) { 

 ย ย ย ย ย ย ย ย playerLevel = newLevel; 

 ย ย ย ย ย ย ย ย if (showNotification) { 

 ย ย ย ย ย ย ย ย ย ย messageBox.textContent = `Level Up! You are now Level ${newLevel}!`; 

 ย ย ย ย ย ย ย ย ย ย sounds.levelUp.triggerAttackRelease("C6", "4n"); 

 ย ย ย ย ย ย ย ย ย ย let rewards = []; 

 ย ย ย ย ย ย ย ย ย ยย 

 ย ย ย ย ย ย ย ย ย ย const featureUnlocks = { 

 ย ย ย ย ย ย ย ย ย ย ย ย 2: { type: 'feature', name: 'Auto-Move', desc: 'You can now <b>double-tap</b> or <b>double-click</b> a card to automatically move it to a valid pile.' }, 

 ย ย ย ย ย ย ย ย ย ย ย ย 3: { type: 'feature', name: 'Hints', desc: 'You can now spend Hint points to find a possible move. You get more hints as you level up!' }, 

 ย ย ย ย ย ย ย ย ย ย ย ย 4: { type: 'feature', name: 'Undo', desc: 'You can now undo your previous move. You get more undos as you level up!' }, 

 ย ย ย ย ย ย ย ย ย ย }; 



 ย ย ย ย ย ย ย ย ย ย for(let l = oldLevel + 1; l <= newLevel; l++) { 

 ย ย ย ย ย ย ย ย ย ย ย ย // Handle feature unlocks 

 ย ย ย ย ย ย ย ย ย ย ย ย if (featureUnlocks[l]) { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย const unlock = featureUnlocks[l]; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย queueUnlockPopup(`โก ${unlock.name} Unlocked!`, unlock.desc); 

 ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย ย ยย 

 ย ย ย ย ย ย ย ย ย ย ย ย // Handle board unlocks (one per level) 

 ย ย ย ย ย ย ย ย ย ย ย ย const boardToUnlock = BOARD_DATA[l - 1]; // Level 2 unlocks index 1, etc. 

 ย ย ย ย ย ย ย ย ย ย ย ย if (boardToUnlock && !unlockedBoards.includes(boardToUnlock.id)) { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย unlockedBoards.push(boardToUnlock.id); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย const applyCallback = () => { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย selectedBoard = boardToUnlock.id; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย updateCardStyles(); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย saveProgress(); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย }; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย queueUnlockPopup('New Board Unlocked!', `You've unlocked the <b>${boardToUnlock.name}</b> background!`, applyCallback); 

 ย ย ย ย ย ย ย ย ย ย ย ย } 



 ย ย ย ย ย ย ย ย ย ย ย ย // Handle card back unlocks (one per level) 

 ย ย ย ย ย ย ย ย ย ย ย ย const cardBackToUnlock = SHUFFLED_CARD_BACKS[l - 1]; 

 ย ย ย ย ย ย ย ย ย ย ย ย if (cardBackToUnlock && !unlockedBacks.includes(cardBackToUnlock.id)) { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย unlockedBacks.push(cardBackToUnlock.id); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย const applyCallback = () => { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย selectedBack = cardBackToUnlock.id; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย updateCardStyles(); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย saveProgress(); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย }; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย queueUnlockPopup('New Card Back Unlocked!', `You've unlocked the <b>${cardBackToUnlock.name}</b> card back!`, applyCallback); 

 ย ย ย ย ย ย ย ย ย ย ย ย } 



 ย ย ย ย ย ย ย ย ย ย ย ย // Handle music unlocks 

 ย ย ย ย ย ย ย ย ย ย ย ย if (l % 2 === 1) { // Unlock on odd levels: 1, 3, 5... 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย const trackIndex = (l - 1) / 2; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย const trackToUnlock = MUSIC_DATA[trackIndex]; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย if (trackToUnlock && !unlockedTracks.includes(trackToUnlock.id)) { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย unlockedTracks.push(trackToUnlock.id); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย const applyCallback = () => { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย playTrackNow(trackToUnlock.url); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย }; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย queueUnlockPopup('๐ต New Music Unlocked!', `<b>${trackToUnlock.name}</b> is now in your playlist!`, applyCallback); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย ย ย } 



 ย ย ย ย ย ย ย ย ย ย ย ย // Handle hint/undo rewards 

 ย ย ย ย ย ย ย ย ย ย ย ย if(l === 3 || (l > 3 && l % 2 !== 0)) { hintsAvailable += 1; rewards.push("+1 Hint"); } 

 ย ย ย ย ย ย ย ย ย ย ย ย if(l === 4 || (l > 4 && l % 2 === 0)) { undosAvailable += 2; rewards.push("+2 Undos"); } 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ยย 

 ย ย ย ย ย ย ย ย ย ย if(rewards.length > 0) messageBox.textContent += ` ${rewards.join(', ')}!`; 

 ย ย ย ย ย ย ย ย ย ย setTimeout(() => messageBox.textContent = '', 4000); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย updatePlayerStatsUI(); 

 ย ย ย ย } 

 ย ย ย ยย 

 ย ย ย ย function updatePlayerStatsUI() { 

 ย ย ย ย ย ย levelTextEl.textContent = `Level ${playerLevel}`; 

 ย ย ย ย ย ย achievementScoreDisplay.textContent = `๐ ${achievementScore}`; 

 ย ย ย ย ย ย const currentLevelXP = LEVEL_THRESHOLDS[playerLevel - 1] || 0; 

 ย ย ย ย ย ย const nextLevelXP = LEVEL_THRESHOLDS[playerLevel] || playerXP; 

 ย ย ย ย ย ย const xpInLevel = playerXP - currentLevelXP; 

 ย ย ย ย ย ย const xpForLevel = nextLevelXP - currentLevelXP; 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย xpTextEl.textContent = `${xpInLevel}/${xpForLevel} XP`; 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย const xpPercentage = xpForLevel > 0 ? `${(xpInLevel / xpForLevel) * 100}%` : '100%'; 

 ย ย ย ย ย ย xpBarEl.style.width = xpPercentage; 





 ย ย ย ย ย ย const hintsUnlocked = playerLevel >= 3; 

 ย ย ย ย ย ย hintBtn.disabled = !hintsUnlocked || hintsAvailable <= 0; 

 ย ย ย ย ย ย if (!hintsUnlocked) { 

 ย ย ย ย ย ย ย ย hintBtn.textContent = '๐ก (Lvl 3)'; 

 ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย hintBtn.textContent = `๐ก Hint (${hintsAvailable})`; 

 ย ย ย ย ย ย } 



 ย ย ย ย ย ย const undosUnlocked = playerLevel >= 4; 

 ย ย ย ย ย ย undoBtn.disabled = !undosUnlocked || undosAvailable <= 0 || moveHistory.length === 0; 

 ย ย ย ย ย ย if (!undosUnlocked) { 

 ย ย ย ย ย ย ย ย undoBtn.textContent = 'โ (Lvl 4)'; 

 ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย undoBtn.textContent = `โ Undo (${undosAvailable})`; 

 ย ย ย ย ย ย } 

 ย ย ย ย } 



 ย ย ย ย function checkAceBonus() { 

 ย ย ย ย ย ย if (aceBonusAwarded) return; 

 ย ย ย ย ย ย const allAcesPlaced = foundations.every(pile => pile.length > 0 && pile[0].rank === 1); 

 ย ย ย ย ย ย if (allAcesPlaced) { 

 ย ย ย ย ย ย ย ย addXP(5, "+5 XP: All Aces Placed!"); 

 ย ย ย ย ย ย ย ย aceBonusAwarded = true; 

 ย ย ย ย ย ย } 

 ย ย ย ย } 



 ย ย ย ย function checkTableauBonus(pileIndex) { 

 ย ย ย ย ย ย if (tableauBonusAwarded[pileIndex]) return; 

 ย ย ย ย ย ย const pile = tableau[pileIndex]; 

 ย ย ย ย ย ย if (pile.length === 13 && pile[0].rank === 13) { 

 ย ย ย ย ย ย ย ย addXP(10, "+10 XP: Full Stack!"); 

 ย ย ย ย ย ย ย ย tableauBonusAwarded[pileIndex] = true; 

 ย ย ย ย ย ย } 

 ย ย ย ย } 



 ย ย ย ย function findHint() { 

 ย ย ย ย ย ย if (playerLevel < 3) { 

 ย ย ย ย ย ย ย ย sounds.error.triggerAttackRelease("G2", "8n"); 

 ย ย ย ย ย ย ย ย messageBox.textContent = 'Unlock Hints at Level 3!'; 

 ย ย ย ย ย ย ย ย setTimeout(() => messageBox.textContent = '', 2000); 

 ย ย ย ย ย ย ย ย return; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย if (hintsAvailable <= 0) { 

 ย ย ย ย ย ย ย ย ยsounds.error.triggerAttackRelease("G2", "8n"); 

 ย ย ย ย ย ย ย ย ยmessageBox.textContent = 'No hints available!'; 

 ย ย ย ย ย ย ย ย ยsetTimeout(() => messageBox.textContent = '', 2000); 

 ย ย ย ย ย ย ย ย ยreturn; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย sounds.click.triggerAttackRelease("E4", "8n"); 



 ย ย ย ย ย ย // Check waste to foundation 

 ย ย ย ย ย ย if (waste.length > 0) { 

 ย ย ย ย ย ย ย ย const card = waste[waste.length - 1]; 

 ย ย ย ย ย ย ย ย for (let i = 0; i < foundations.length; i++) { if (isValidFoundationMove(card, i)) { glowHint(card.id, foundations[i].length > 0 ? foundations[i][foundations[i].length-1].id : `foundation-${i}`); useHint(); return; } } 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย // Check tableau to foundation 

 ย ย ย ย ย ย for (let i = 0; i < tableau.length; i++) { 

 ย ย ย ย ย ย ย ย if (tableau[i].length > 0) { 

 ย ย ย ย ย ย ย ย ย ย const card = tableau[i][tableau[i].length - 1]; 

 ย ย ย ย ย ย ย ย ย ย for (let f = 0; f < foundations.length; f++) { if (isValidFoundationMove(card, f)) { glowHint(card.id, foundations[f].length > 0 ? foundations[f][foundations[f].length-1].id : `foundation-${f}`); useHint(); return; } } 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย // Check tableau to tableau 

 ย ย ย ย ย ย for (let i = 0; i < tableau.length; i++) { 

 ย ย ย ย ย ย ย ย if (tableau[i].length > 0) { 

 ย ย ย ย ย ย ย ย ย ย for (let k = 0; k < tableau[i].length; k++) { 

 ย ย ย ย ย ย ย ย ย ย ย ย if(tableau[i][k].isFaceUp) { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย const card = tableau[i][k]; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย for (let j = 0; j < tableau.length; j++) { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย if (i === j) continue; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย if (isValidTableauMove(card, j)) { glowHint(card.id, tableau[j].length > 0 ? tableau[j][tableau[j].length-1].id : `tableau-${j}`); useHint(); return; } 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย // Check waste to tableau 

 ย ย ย ย ย ย if (waste.length > 0) { 

 ย ย ย ย ย ย ย ย const card = waste[waste.length-1]; 

 ย ย ย ย ย ย ย ย for (let i = 0; i < tableau.length; i++) { if (isValidTableauMove(card, i)) { glowHint(card.id, tableau[i].length > 0 ? tableau[i][tableau[i].length-1].id : `tableau-${i}`); useHint(); return; } } 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย messageBox.textContent = 'No moves found!'; 

 ย ย ย ย ย ย setTimeout(() => messageBox.textContent = '', 2000); 

 ย ย ย ย } 



 ย ย ย ย function useHint() { 

 ย ย ย ย ย ย hintsAvailable--; 

 ย ย ย ย ย ย updatePlayerStatsUI(); 

 ย ย ย ย ย ย saveProgress(); 

 ย ย ย ย } 



 ย ย ย ย function glowHint(sourceCardId, targetId) { 

 ย ย ย ย ย ย document.querySelectorAll('.hint-glow').forEach(el => el.classList.remove('hint-glow')); 

 ย ย ย ย ย ย const sourceEl = document.querySelector(`[data-card-id="${sourceCardId}"]`); 

 ย ย ย ย ย ย let targetEl = document.querySelector(`[data-card-id="${targetId}"]`); 

 ย ย ย ย ย ย if (!targetEl) targetEl = document.getElementById(targetId); 



 ย ย ย ย ย ย if (sourceEl) sourceEl.classList.add('hint-glow'); 

 ย ย ย ย ย ย if (targetEl) targetEl.classList.add('hint-glow'); 



 ย ย ย ย ย ย setTimeout(() => { 

 ย ย ย ย ย ย ย ย if (sourceEl) sourceEl.classList.remove('hint-glow'); 

 ย ย ย ย ย ย ย ย if (targetEl) targetEl.classList.remove('hint-glow'); 

 ย ย ย ย ย ย }, 1500); 

 ย ย ย ย } 



 ย ย ย ย // --- Undo Logic --- 

 ย ย ย ย function saveState() { 

 ย ย ย ย ย ย const state = { 

 ย ย ย ย ย ย ย ย stock: JSON.parse(JSON.stringify(stock)), 

 ย ย ย ย ย ย ย ย waste: JSON.parse(JSON.stringify(waste)), 

 ย ย ย ย ย ย ย ย foundations: JSON.parse(JSON.stringify(foundations)), 

 ย ย ย ย ย ย ย ย tableau: JSON.parse(JSON.stringify(tableau)), 

 ย ย ย ย ย ย ย ย aceBonusAwarded: aceBonusAwarded, 

 ย ย ย ย ย ย ย ย tableauBonusAwarded: [...tableauBonusAwarded], 

 ย ย ย ย ย ย ย ย playerXP: playerXP, 

 ย ย ย ย ย ย ย ย hintsAvailable: hintsAvailable, 

 ย ย ย ย ย ย ย ย undosAvailable: undosAvailable 

 ย ย ย ย ย ย }; 

 ย ย ย ย ย ย moveHistory.push(state); 

 ย ย ย ย ย ย updatePlayerStatsUI(); 

 ย ย ย ย } 



 ย ย ย ย function undoMove() { 

 ย ย ย ย ย ย if (playerLevel < 4) { 

 ย ย ย ย ย ย ย ย sounds.error.triggerAttackRelease("G2", "8n"); 

 ย ย ย ย ย ย ย ย messageBox.textContent = 'Unlock Undo at Level 4!'; 

 ย ย ย ย ย ย ย ย setTimeout(() => messageBox.textContent = '', 2000); 

 ย ย ย ย ย ย ย ย return; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย if (moveHistory.length === 0 || undosAvailable <= 0) { 

 ย ย ย ย ย ย ย ย sounds.error.triggerAttackRelease("G2", "8n"); 

 ย ย ย ย ย ย ย ย return; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย sounds.click.triggerAttackRelease("A2", "8n"); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย const lastState = moveHistory.pop(); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย stock = lastState.stock; 

 ย ย ย ย ย ย waste = lastState.waste; 

 ย ย ย ย ย ย foundations = lastState.foundations; 

 ย ย ย ย ย ย tableau = lastState.tableau; 

 ย ย ย ย ย ย aceBonusAwarded = lastState.aceBonusAwarded; 

 ย ย ย ย ย ย tableauBonusAwarded = lastState.tableauBonusAwarded; 

 ย ย ย ย ย ย playerXP = lastState.playerXP; 

 ย ย ย ย ย ย hintsAvailable = lastState.hintsAvailable; 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย undosAvailable--; 



 ย ย ย ย ย ย resetCombo(); 

 ย ย ย ย ย ย updatePlayerStatsUI(); 

 ย ย ย ย ย ย saveProgress(); 

 ย ย ย ย ย ย render(); 

 ย ย ย ย } 



 ย ย ย ย // --- Win Logic & Animations --- 

 ย ย ย ย function checkWinCondition() { 

 ย ย ย ย ย ย if (foundations.reduce((sum, pile) => sum + pile.length, 0) === 52) { 

 ย ย ย ย ย ย ย ย if (!isGameWon) { 

 ย ย ย ย ย ย ย ย ย ย isGameWon = true; 

 ย ย ย ย ย ย ย ย ย ย stopTimer(); 

 ย ย ย ย ย ย ย ย ย ย messageBox.textContent = '๐ You Win! ๐'; 

 ย ย ย ย ย ย ย ย ย ย autocompleteBtn.classList.add('hidden'); 

 ย ย ย ย ย ย ย ย ย ย gameBoard.style.pointerEvents = 'none'; 

 ย ย ย ย ย ย ย ย ย ยย 

 ย ย ย ย ย ย ย ย ย ย winCount++; 

 ย ย ย ย ย ย ย ย ย ย winStreak++; 

 ย ย ย ย ย ย ย ย ย ย const winBonus = drawCount === 3 ? 20 : 10; 

 ย ย ย ย ย ย ย ย ย ย addXP(winBonus, `+${winBonus} XP: You Win!`); 

 ย ย ย ย ย ย ย ย ย ย hintsAvailable++; 



 ย ย ย ย ย ย ย ย ย ย saveProgress(); 

 ย ย ย ย ย ย ย ย ย ยย 

 ย ย ย ย ย ย ย ย ย ย const now = Tone.now(); 

 ย ย ย ย ย ย ย ย ย ย sounds.win.triggerAttackRelease("C4", "2n", now); 

 ย ย ย ย ย ย ย ย ย ย sounds.win.triggerAttackRelease("E4", "2n", now + 0.2); 

 ย ย ย ย ย ย ย ย ย ย sounds.win.triggerAttackRelease("G4", "2n", now + 0.4); 

 ย ย ย ย ย ย ย ย ย ย sounds.win.triggerAttackRelease("C5", "1n", now + 0.6); 

 ย ย ย ย ย ย ย ย ย ยย 

 ย ย ย ย ย ย ย ย ย ย const winAnimations = [winAnimationConfetti, winAnimationVortex, winAnimationFountain, winAnimationCascade, winAnimationShuffle]; 

 ย ย ย ย ย ย ย ย ย ย const randomAnimation = winAnimations[Math.floor(Math.random() * winAnimations.length)]; 

 ย ย ย ย ย ย ย ย ย ย randomAnimation(); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย } 

 ย ย ย ย function checkAutocomplete() { if (isGameWon) return; const allTableauFaceUp = tableau.every(pile => pile.every(card => card.isFaceUp)); const isStockEmpty = stock.length === 0 && waste.length === 0; if (allTableauFaceUp && isStockEmpty) { autocompleteBtn.classList.remove('hidden'); } else { autocompleteBtn.classList.add('hidden'); } } 

 ย ย ย ย async function runAutocomplete() { 

 ย ย ย ย ย ย autocompleteBtn.classList.add('hidden'); 

 ย ย ย ย ย ย gameBoard.style.pointerEvents = 'none'; 

 ย ย ย ย ย ย let movableCardFound = true; 

 ย ย ย ย ย ย while (movableCardFound) { 

 ย ย ย ย ย ย ย ย movableCardFound = false; 

 ย ย ย ย ย ย ย ย for (let i = tableau.length - 1; i >= 0; i--) { 

 ย ย ย ย ย ย ย ย ย ย const pile = tableau[i]; 

 ย ย ย ย ย ย ย ย ย ย if (pile.length > 0) { 

 ย ย ย ย ย ย ย ย ย ย ย ย const card = pile[pile.length - 1]; 

 ย ย ย ย ย ย ย ย ย ย ย ย const cardEl = document.querySelector(`[data-card-id="${card.id}"]`); 

 ย ย ย ย ย ย ย ย ย ย ย ย for (let f = 0; f < foundations.length; f++) { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย if (isValidFoundationMove(card, f)) { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย saveState(); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย sounds.foundationPlace.triggerAttackRelease("C5", "8n"); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย addXP(1, "+1 XP"); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย const targetId = foundationEls[f].id; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย await animateAndMoveCard(cardEl, targetId, () => { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย moveCards('tableau', i, 'foundation', f, 1); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย movableCardFound = true; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย ย break; 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย if (movableCardFound) break; 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย } 



 ย ย ย ย function winAnimationConfetti() { 

 ย ย ย ย ย ย comboCanvas.style.pointerEvents = 'auto'; 

 ย ย ย ย ย ย const { Bodies, World } = Matter; 

 ย ย ย ย ย ย const cardWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-width')); 

 ย ย ย ย ย ย const cardHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-height')); 



 ย ย ย ย ย ย const fullDeck = createDeck(); 

 ย ย ย ย ย ย fullDeck.forEach((card, i) => { 

 ย ย ย ย ย ย ย ย setTimeout(() => { 

 ย ย ย ย ย ย ย ย ย ย const cardBody = Bodies.rectangle( 

 ย ย ย ย ย ย ย ย ย ย ย ย window.innerWidth / 2, window.innerHeight / 2, cardWidth, cardHeight, 

 ย ย ย ย ย ย ย ย ย ย ย ย { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย restitution: 0.7, 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย friction: 0.1, 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย angle: Math.random() * Math.PI * 2, 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย render: { sprite: { texture: createCardTexture(card), xScale: 1, yScale: 1 } } 

 ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย ); 

 ย ย ย ย ย ย ย ย ย ย Matter.Body.applyForce(cardBody, cardBody.position, { 

 ย ย ย ย ย ย ย ย ย ย ย ย x: (Math.random() - 0.5) * 0.5, 

 ย ย ย ย ย ย ย ย ย ย ย ย y: (Math.random() - 0.5) * 0.5 

 ย ย ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย ย ย ย ย World.add(world, cardBody); 

 ย ย ย ย ย ย ย ย }, i * 20); 

 ย ย ย ย ย ย }); 



 ย ย ย ย ย ย winAnimationTimeout = setTimeout(() => { 

 ย ย ย ย ย ย ย ย Matter.World.clear(world, false); 

 ย ย ย ย ย ย ย ย comboCanvas.style.pointerEvents = 'none'; 

 ย ย ย ย ย ย }, 30000); 

 ย ย ย ย } 



 ย ย ย ย function winAnimationVortex() { 

 ย ย ย ย ย ย comboCanvas.style.pointerEvents = 'auto'; 

 ย ย ย ย ย ย const { Bodies, World, Body } = Matter; 

 ย ย ย ย ย ย const cardWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-width')); 

 ย ย ย ย ย ย const cardHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-height')); 

 ย ย ย ย ย ย const fullDeck = createDeck(); 

 ย ย ย ย ย ย const cardBodies = []; 



 ย ย ย ย ย ย fullDeck.forEach((card, i) => { 

 ย ย ย ย ย ย ย ย setTimeout(() => { 

 ย ย ย ย ย ย ย ย ย ย const cardBody = Bodies.rectangle( 

 ย ย ย ย ย ย ย ย ย ย ย ย Math.random() * window.innerWidth, Math.random() * window.innerHeight, cardWidth, cardHeight, 

 ย ย ย ย ย ย ย ย ย ย ย ย { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย render: { sprite: { texture: createCardTexture(card), xScale: 1, yScale: 1 } } 

 ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย ); 

 ย ย ย ย ย ย ย ย ย ย cardBodies.push(cardBody); 

 ย ย ย ย ย ย ย ย ย ย World.add(world, cardBody); 

 ย ย ย ย ย ย ย ย }, i * 20); 

 ย ย ย ย ย ย }); 



 ย ย ย ย ย ย const vortexInterval = setInterval(() => { 

 ย ย ย ย ย ย ย ย cardBodies.forEach(body => { 

 ย ย ย ย ย ย ย ย ย ย const dx = window.innerWidth / 2 - body.position.x; 

 ย ย ย ย ย ย ย ย ย ย const dy = window.innerHeight / 2 - body.position.y; 

 ย ย ย ย ย ย ย ย ย ย const dist = Math.sqrt(dx * dx + dy * dy); 

 ย ย ย ย ย ย ย ย ย ย if (dist > 10) { 

 ย ย ย ย ย ย ย ย ย ย ย ย Body.applyForce(body, body.position, { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย x: dx * 0.001, 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย y: dy * 0.001 

 ย ย ย ย ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย ย ย ย ย ย ย Body.setAngularVelocity(body, 0.1); 

 ย ย ย ย ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย ย ย ย ย World.remove(world, body); 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย }, 16); 



 ย ย ย ย ย ย winAnimationTimeout = setTimeout(() => { 

 ย ย ย ย ย ย ย ย clearInterval(vortexInterval); 

 ย ย ย ย ย ย ย ย Matter.World.clear(world, false); 

 ย ย ย ย ย ย ย ย comboCanvas.style.pointerEvents = 'none'; 

 ย ย ย ย ย ย }, 30000); 

 ย ย ย ย } 



 ย ย ย ย function winAnimationFountain() { 

 ย ย ย ย ย ย comboCanvas.style.pointerEvents = 'auto'; 

 ย ย ย ย ย ย const { Bodies, World } = Matter; 

 ย ย ย ย ย ย const cardWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-width')); 

 ย ย ย ย ย ย const cardHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-height')); 

 ย ย ย ย ย ย const fullDeck = createDeck(); 



 ย ย ย ย ย ย fullDeck.forEach((card, i) => { 

 ย ย ย ย ย ย ย ย setTimeout(() => { 

 ย ย ย ย ย ย ย ย ย ย const cardBody = Bodies.rectangle( 

 ย ย ย ย ย ย ย ย ย ย ย ย window.innerWidth / 2, window.innerHeight, cardWidth, cardHeight, 

 ย ย ย ย ย ย ย ย ย ย ย ย { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย restitution: 0.2, 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย render: { sprite: { texture: createCardTexture(card), xScale: 1, yScale: 1 } } 

 ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย ); 

 ย ย ย ย ย ย ย ย ย ย Matter.Body.applyForce(cardBody, cardBody.position, { 

 ย ย ย ย ย ย ย ย ย ย ย ย x: (Math.random() - 0.5) * 0.1, 

 ย ย ย ย ย ย ย ย ย ย ย ย y: -0.2 

 ย ย ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย ย ย ย ย World.add(world, cardBody); 

 ย ย ย ย ย ย ย ย }, i * 50); 

 ย ย ย ย ย ย }); 



 ย ย ย ย ย ย winAnimationTimeout = setTimeout(() => { 

 ย ย ย ย ย ย ย ย Matter.World.clear(world, false); 

 ย ย ย ย ย ย ย ย comboCanvas.style.pointerEvents = 'none'; 

 ย ย ย ย ย ย }, 30000); 

 ย ย ย ย } 



 ย ย ย ย function winAnimationCascade() { 

 ย ย ย ย ย ย comboCanvas.style.pointerEvents = 'auto'; 

 ย ย ย ย ย ย const { Bodies, World } = Matter; 

 ย ย ย ย ย ย const cardWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-width')); 

 ย ย ย ย ย ย const cardHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-height')); 

 ย ย ย ย ย ย const fullDeck = createDeck(); 



 ย ย ย ย ย ย fullDeck.forEach((card, i) => { 

 ย ย ย ย ย ย ย ย setTimeout(() => { 

 ย ย ย ย ย ย ย ย ย ย const cardBody = Bodies.rectangle( 

 ย ย ย ย ย ย ย ย ย ย ย ย Math.random() * window.innerWidth, -100, cardWidth, cardHeight, 

 ย ย ย ย ย ย ย ย ย ย ย ย { 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย restitution: 0.5, 

 ย ย ย ย ย ย ย ย ย ย ย ย ย ย render: { sprite: { texture: createCardTexture(card), xScale: 1, yScale: 1 } } 

 ย ย ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ย ย ); 

 ย ย ย ย ย ย ย ย ย ย World.add(world, cardBody); 

 ย ย ย ย ย ย ย ย }, i * 50); 

 ย ย ย ย ย ย }); 



 ย ย ย ย ย ย winAnimationTimeout = setTimeout(() => { 

 ย ย ย ย ย ย ย ย Matter.World.clear(world, false); 

 ย ย ย ย ย ย ย ย comboCanvas.style.pointerEvents = 'none'; 

 ย ย ย ย ย ย }, 30000); 

 ย ย ย ย } 



 ย ย ย ย function winAnimationShuffle() { 

 ย ย ย ย ย ย comboCanvas.style.pointerEvents = 'auto'; 

 ย ย ย ย ย ย const { Bodies, World, Body } = Matter; 

 ย ย ย ย ย ย const cardWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-width')); 

 ย ย ย ย ย ย const cardHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-height')); 

 ย ย ย ย ย ย const fullDeck = createDeck(); 

 ย ย ย ย ย ย const cardBodies = []; 



 ย ย ย ย ย ย fullDeck.forEach((card, i) => { 

 ย ย ย ย ย ย ย ย const cardBody = Bodies.rectangle( 

 ย ย ย ย ย ย ย ย ย ย Math.random() * window.innerWidth, Math.random() * window.innerHeight, cardWidth, cardHeight, 

 ย ย ย ย ย ย ย ย ย ย { 

 ย ย ย ย ย ย ย ย ย ย ย ย frictionAir: 0.05, 

 ย ย ย ย ย ย ย ย ย ย ย ย render: { sprite: { texture: createCardTexture(card), xScale: 1, yScale: 1 } } 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย ); 

 ย ย ย ย ย ย ย ย cardBodies.push(cardBody); 

 ย ย ย ย ย ย ย ย World.add(world, cardBody); 

 ย ย ย ย ย ย }); 



 ย ย ย ย ย ย const shuffleInterval = setInterval(() => { 

 ย ย ย ย ย ย ย ย cardBodies.forEach(body => { 

 ย ย ย ย ย ย ย ย ย ย Body.applyForce(body, body.position, { 

 ย ย ย ย ย ย ย ย ย ย ย ย x: (Math.random() - 0.5) * 0.1, 

 ย ย ย ย ย ย ย ย ย ย ย ย y: (Math.random() - 0.5) * 0.1 

 ย ย ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย }, 500); 



 ย ย ย ย ย ย winAnimationTimeout = setTimeout(() => { 

 ย ย ย ย ย ย ย ย clearInterval(shuffleInterval); 

 ย ย ย ย ย ย ย ย Matter.World.clear(world, false); 

 ย ย ย ย ย ย ย ย comboCanvas.style.pointerEvents = 'none'; 

 ย ย ย ย ย ย }, 30000); 

 ย ย ย ย } 



 ย ย ย ย function createCardTexture(card) { 

 ย ย ย ย ย ย const canvas = document.createElement('canvas'); 

 ย ย ย ย ย ย canvas.width = varToNum('--card-width'); 

 ย ย ย ย ย ย canvas.height = varToNum('--card-height'); 

 ย ย ย ย ย ย const ctx = canvas.getContext('2d'); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-bg'); 

 ย ย ย ย ย ย ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-border'); 

 ย ย ย ย ย ย ctx.lineWidth = 2; 

 ย ย ย ย ย ย ctx.beginPath(); 

 ย ย ย ย ย ย ctx.moveTo(8, 0); 

 ย ย ย ย ย ย ctx.lineTo(canvas.width - 8, 0); 

 ย ย ย ย ย ย ctx.quadraticCurveTo(canvas.width, 0, canvas.width, 8); 

 ย ย ย ย ย ย ctx.lineTo(canvas.width, canvas.height - 8); 

 ย ย ย ย ย ย ctx.quadraticCurveTo(canvas.width, canvas.height, canvas.width - 8, canvas.height); 

 ย ย ย ย ย ย ctx.lineTo(8, canvas.height); 

 ย ย ย ย ย ย ctx.quadraticCurveTo(0, canvas.height, 0, canvas.height - 8); 

 ย ย ย ย ย ย ctx.lineTo(0, 8); 

 ย ย ย ย ย ย ctx.quadraticCurveTo(0, 0, 8, 0); 

 ย ย ย ย ย ย ctx.closePath(); 

 ย ย ย ย ย ย ctx.fill(); 

 ย ย ย ย ย ย ctx.stroke(); 



 ย ย ย ย ย ย ctx.fillStyle = card.color === 'red' ? '#d90429' : '#000000'; 

 ย ย ย ย ย ย ctx.font = `bold 28px 'Segoe UI', sans-serif`; 

 ย ย ย ย ย ย ctx.textAlign = 'left'; 

 ย ย ย ย ย ย ctx.textBaseline = 'top'; 

 ย ย ย ย ย ย ctx.fillText(`${card.value}${card.suit}`, 10, 10); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย ctx.save(); 

 ย ย ย ย ย ย ctx.translate(canvas.width, canvas.height); 

 ย ย ย ย ย ย ctx.rotate(Math.PI); 

 ย ย ย ย ย ย ctx.fillText(`${card.value}${card.suit}`, 10, 10); 

 ย ย ย ย ย ย ctx.restore(); 



 ย ย ย ย ย ย return canvas.toDataURL(); 

 ย ย ย ย } 



 ย ย ย ย function varToNum(varName) { 

 ย ย ย ย ย ย return parseFloat(getComputedStyle(document.documentElement).getPropertyValue(varName)); 

 ย ย ย ย } 

 ย ย ย ยย 

 ย ย ย ย // --- Timer --- 

 ย ย ย ย function startTimer() { 

 ย ย ย ย ย ย stopTimer(); 

 ย ย ย ย ย ย gameTime = 0; 

 ย ย ย ย ย ย gameTimerInterval = setInterval(() => { 

 ย ย ย ย ย ย ย ย gameTime++; 

 ย ย ย ย ย ย ย ย const minutes = Math.floor(gameTime / 60).toString().padStart(2, '0'); 

 ย ย ย ย ย ย ย ย const seconds = (gameTime % 60).toString().padStart(2, '0'); 

 ย ย ย ย ย ย ย ย gameTimerEl.textContent = `${minutes}:${seconds}`; 

 ย ย ย ย ย ย }, 1000); 

 ย ย ย ย } 

 ย ย ย ย function stopTimer() { 

 ย ย ย ย ย ย clearInterval(gameTimerInterval); 

 ย ย ย ย } 



 ย ย ย ย // --- Achievement System --- 

 ย ย ย ย function triggerAchievement(id) { 

 ย ย ย ย ย ย if (unlockedAchievements.includes(id)) return; 



 ย ย ย ย ย ย const achievement = ACHIEVEMENTS[id]; 

 ย ย ย ย ย ย unlockedAchievements.push(id); 

 ย ย ย ย ย ย achievementScore += achievement.points; 

 ย ย ย ย ย ย addXP(achievement.xp, `Achievement: ${achievement.name}`); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย const toast = document.createElement('div'); 

 ย ย ย ย ย ย toast.className = 'achievement-toast'; 

 ย ย ย ย ย ย toast.innerHTML = ` 

 ย ย ย ย ย ย ย ย <div class="achievement-icon">${achievement.icon}</div> 

 ย ย ย ย ย ย ย ย <div class="achievement-details"> 

 ย ย ย ย ย ย ย ย ย ย <h4>${achievement.name}</h4> 

 ย ย ย ย ย ย ย ย ย ย <p>${achievement.desc}</p> 

 ย ย ย ย ย ย ย ย </div> 

 ย ย ย ย ย ย `; 

 ย ย ย ย ย ย achievementContainer.appendChild(toast); 

 ย ย ย ย ย ย sounds.achievement.triggerAttackRelease("C5", "8n"); 



 ย ย ย ย ย ย setTimeout(() => { 

 ย ย ย ย ย ย ย ย toast.remove(); 

 ย ย ย ย ย ย }, 5000); 



 ย ย ย ย ย ย updatePlayerStatsUI(); 

 ย ย ย ย ย ย saveProgress(); 

 ย ย ย ย } 

 ย ย ย ยย 

 ย ย ย ย function renderAchievementList() { 

 ย ย ย ย ย ย achievementListEl.innerHTML = ''; 

 ย ย ย ย ย ย Object.keys(ACHIEVEMENTS).forEach(id => { 

 ย ย ย ย ย ย ย ย const ach = ACHIEVEMENTS[id]; 

 ย ย ย ย ย ย ย ย if (ach.secret && !unlockedAchievements.includes(id)) return; 



 ย ย ย ย ย ย ย ย const entry = document.createElement('div'); 

 ย ย ย ย ย ย ย ย entry.className = 'achievement-entry'; 

 ย ย ย ย ย ย ย ย if (unlockedAchievements.includes(id)) { 

 ย ย ย ย ย ย ย ย ย ย entry.classList.add('unlocked'); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย entry.innerHTML = ` 

 ย ย ย ย ย ย ย ย ย ย <div class="achievement-entry-icon">${ach.icon}</div> 

 ย ย ย ย ย ย ย ย ย ย <div class="achievement-entry-details"> 

 ย ย ย ย ย ย ย ย ย ย ย ย <h4>${ach.name} (+${ach.points}๐)</h4> 

 ย ย ย ย ย ย ย ย ย ย ย ย <p>${ach.desc}</p> 

 ย ย ย ย ย ย ย ย ย ย </div> 

 ย ย ย ย ย ย ย ย `; 

 ย ย ย ย ย ย ย ย achievementListEl.appendChild(entry); 

 ย ย ย ย ย ย }); 

 ย ย ย ย } 



 ย ย ย ย // --- Fullscreen Logic --- 

 ย ย ย ย function toggleFullScreen() { 

 ย ย ย ย ย ย const docEl = document.documentElement; 

 ย ย ย ย ย ย const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullscreen || docEl.msRequestFullscreen; 

 ย ย ย ย ย ย const cancelFullScreen = document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.msExitFullscreen; 



 ย ย ย ย ย ย if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) { 

 ย ย ย ย ย ย ย ย if (requestFullScreen) { 

 ย ย ย ย ย ย ย ย ย ย requestFullScreen.call(docEl).catch(err => { 

 ย ย ย ย ย ย ย ย ย ย ย ย console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`); 

 ย ย ย ย ย ย ย ย ย ย }); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย if (cancelFullScreen) { 

 ย ย ย ย ย ย ย ย ย ย cancelFullScreen.call(document); 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย } 

 ย ย ย ย } 



 ย ย ย ย function updateFullscreenIcon() { 

 ย ย ย ย ย ย if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) { 

 ย ย ย ย ย ย ย ย fullscreenIcon.style.display = 'none'; 

 ย ย ย ย ย ย ย ย exitFullscreenIcon.style.display = 'block'; 

 ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย fullscreenIcon.style.display = 'block'; 

 ย ย ย ย ย ย ย ย exitFullscreenIcon.style.display = 'none'; 

 ย ย ย ย ย ย } 

 ย ย ย ย } 



 ย ย ย ย fullscreenBtn.addEventListener('click', toggleFullScreen); 

 ย ย ย ย document.addEventListener('fullscreenchange', updateFullscreenIcon); 

 ย ย ย ย document.addEventListener('webkitfullscreenchange', updateFullscreenIcon); 

 ย ย ย ย document.addEventListener('mozfullscreenchange', updateFullscreenIcon); 

 ย ย ย ย document.addEventListener('MSFullscreenChange', updateFullscreenIcon); 



 ย ย ย ย // --- Mute Logic --- 

 ย ย ย ย function updateMuteState(playSound = true) { 

 ย ย ย ย ย ย Tone.Master.mute = isMuted; 

 ย ย ย ย ย ย if (isMuted) { 

 ย ย ย ย ย ย ย ย unmutedIcon.style.display = 'none'; 

 ย ย ย ย ย ย ย ย mutedIcon.style.display = 'block'; 

 ย ย ย ย ย ย } else { 

 ย ย ย ย ย ย ย ย unmutedIcon.style.display = 'block'; 

 ย ย ย ย ย ย ย ย mutedIcon.style.display = 'none'; 

 ย ย ย ย ย ย ย ย if(playSound && sounds) sounds.click.triggerAttackRelease("C3", "8n"); 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย saveProgress(); 

 ย ย ย ย } 



 ย ย ย ย muteBtn.addEventListener('click', () => { 

 ย ย ย ย ย ย isMuted = !isMuted; 

 ย ย ย ย ย ย updateMuteState(); 

 ย ย ย ย }); 



 ย ย ย ย // --- Music Logic --- 

 ย ย ย ย function playNextTrack() { 

 ย ย ย ย ย ย if (currentTrackPlayer) { 

 ย ย ย ย ย ย ย ย currentTrackPlayer.dispose(); 

 ย ย ย ย ย ย } 

 ย ย ย ยย 

 ย ย ย ย ย ย if (shuffledPlaylist.length === 0) { 

 ย ย ย ย ย ย ย ย shuffledPlaylist = unlockedTracks.map(trackId => MUSIC_DATA.find(t => t.id === trackId).url); 

 ย ย ย ย ย ย ย ย shuffleArray(shuffledPlaylist); 

 ย ย ย ย ย ย ย ย currentTrackIndex = -1; 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย currentTrackIndex = (currentTrackIndex + 1) % shuffledPlaylist.length; 

 ย ย ย ย ย ย const nextTrackUrl = shuffledPlaylist[currentTrackIndex]; 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย currentTrackPlayer = new Tone.Player({ 

 ย ย ย ย ย ย ย ย url: nextTrackUrl, 

 ย ย ย ย ย ย ย ย autostart: true, 

 ย ย ย ย ย ย ย ย onstop: () => { 

 ย ย ย ย ย ย ย ย ย ย if (Tone.Transport.state === 'started') { 

 ย ย ย ย ย ย ย ย ย ย ย ย playNextTrack(); 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย }).toDestination(); 

 ย ย ย ย } 

 ย ย ย ยย 

 ย ย ย ย function startMainPlaylist() { 

 ย ย ย ย ย ย if (Tone.Transport.state === 'started') { 

 ย ย ย ย ย ย ย ย Tone.Transport.stop(); 

 ย ย ย ย ย ย ย ย if(currentTrackPlayer) currentTrackPlayer.stop(); 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย shuffledPlaylist = unlockedTracks.map(trackId => MUSIC_DATA.find(t => t.id === trackId).url); 

 ย ย ย ย ย ย shuffleArray(shuffledPlaylist); 

 ย ย ย ย ย ย currentTrackIndex = -1; 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย Tone.Transport.start(); 

 ย ย ย ย ย ย playNextTrack(); 

 ย ย ย ย } 



 ย ย ย ย function playTrackNow(trackUrl) { 

 ย ย ย ย ย ย if (currentTrackPlayer) { 

 ย ย ย ย ย ย ย ย currentTrackPlayer.stop(); 

 ย ย ย ย ย ย ย ย currentTrackPlayer.dispose(); 

 ย ย ย ย ย ย } 

 ย ย ย ย ย ย currentTrackPlayer = new Tone.Player({ 

 ย ย ย ย ย ย ย ย url: trackUrl, 

 ย ย ย ย ย ย ย ย autostart: true, 

 ย ย ย ย ย ย ย ย onstop: () => { 

 ย ย ย ย ย ย ย ย ย ย if (Tone.Transport.state === 'started') { 

 ย ย ย ย ย ย ย ย ย ย ย ย playNextTrack(); 

 ย ย ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย ย ย } 

 ย ย ย ย ย ย }).toDestination(); 

 ย ย ย ย ย ยย 

 ย ย ย ย ย ย // Rebuild the shuffled playlist to include the new track immediately 

 ย ย ย ย ย ย shuffledPlaylist = unlockedTracks.map(trackId => MUSIC_DATA.find(t => t.id === trackId).url); 

 ย ย ย ย ย ย shuffleArray(shuffledPlaylist); 

 ย ย ย ย ย ย // Set the current track index to the newly played track to avoid repetition 

 ย ย ย ย ย ย currentTrackIndex = shuffledPlaylist.indexOf(trackUrl); 

 ย ย ย ย } 



 ย ย ย ย // --- Reset Progress Logic --- 

 ย ย ย ย resetProgressBtn.addEventListener('click', () => { 

 ย ย ย ย ย ย resetConfirmModal.style.display = 'flex'; 

 ย ย ย ย }); 



 ย ย ย ย resetCancelBtn.addEventListener('click', () => { 

 ย ย ย ย ย ย resetConfirmModal.style.display = 'none'; 

 ย ย ย ย }); 



 ย ย ย ย resetConfirmBtn.addEventListener('click', () => { 

 ย ย ย ย ย ย localStorage.clear(); 

 ย ย ย ย ย ย location.reload(); 

 ย ย ย ย }); 





 ย ย ย ย // --- Initial Setup --- 

 ย ย ย ย // Final setup calls when the DOM is fully loaded. 

 ย ย ย ย animateTitleScreen(); 

 ย ย ย ย window.addEventListener('resize', () => { 

 ย ย ย ย ย ย updatePlayerStatsUI(); 

 ย ย ย ย ย ย // Re-initialize animated backgrounds on resize to fit new dimensions 

 ย ย ย ย ย ย if (starfieldAnimationId) setupStarfield(); 

 ย ย ย ย ย ย if (lavalampAnimationId) setupLavalamp(); 

 ย ย ย ย ย ย if (oceanAnimationId) setupOcean(); 

 ย ย ย ย ย ย if (matrixAnimationId) setupMatrix(); 

 ย ย ย ย ย ย if (geometricAnimationId) setupGeometric(); 

 ย ย ย ย ย ย if (fireAnimationId) setupFire(); 

 ย ย ย ย ย ย if (rainAnimationId) setupRain(); 

 ย ย ย ย ย ย if (hyperspaceAnimationId) setupHyperspace(); 

 ย ย ย ย ย ย if (plasmaAnimationId) setupPlasma(); 

 ย ย ย ย ย ย if (forestAnimationId) setupForest(); 

 ย ย ย ย ย ย if (neongridAnimationId) setupNeonGrid(); 

 ย ย ย ย ย ย if (sakuraAnimationId) setupSakura(); 

 ย ย ย ย ย ย if (quantumAnimationId) setupQuantum(); 

 ย ย ย ย ย ย if (digitalrainAnimationId) setupDigitalRain(); 

 ย ย ย ย ย ย if (sandsAnimationId) setupSands(); 

 ย ย ย ย ย ย if (inkblotAnimationId) setupInkBlot(); 

 ย ย ย ย ย ย if (cosmicAnimationId) setupCosmic(); 

 ย ย ย ย ย ย if (musicvizAnimationId) setupMusicViz(); 

 ย ย ย ย ย ย if (bioforestAnimationId) setupBioForest(); 

 ย ย ย ย ย ย if (wateryAnimationId) setupWatery(); 

 ย ย ย ย ย ย if (stainedglassAnimationId) setupStainedGlass(); 

 ย ย ย ย ย ย if (swarmAnimationId) setupSwarm(); 

 ย ย ย ย ย ย if (glitchAnimationId) setupGlitch(); 

 ย ย ย ย ย ย if (auroraAnimationId) setupAurora(); 

 ย ย ย ย ย ย if (constellationAnimationId) setupConstellation(); 

 ย ย ย ย ย ย if (synthwaveAnimationId) setupSynthwave(); 

 ย ย ย ย ย ย if (nebulaAnimationId) setupNebula(); 

 ย ย ย ย ย ย if (jungleAnimationId) setupJungle(); 

 ย ย ย ย ย ย if (cityscapeAnimationId) setupCityscape(); 

 ย ย ย ย ย ย if (paintAnimationId) setupPaint(); 

 ย ย ย ย ย ย if (laserGridAnimationId) setupLaserGrid(); 

 ย ย ย ย ย ย if (neonPalmsAnimationId) setupNeonPalms(); 

 ย ย ย ย ย ย if (memphisAnimationId) setupMemphis(); 

 ย ย ย ย ย ย if (cassetteAnimationId) setupCassette(); 

 ย ย ย ย ย ย if (eightBitCityAnimationId) setupEightBitCity(); 

 ย ย ย ย }); 



 ย ย ย ย window.addEventListener('mousemove', (e) => { 

 ย ย ย ย ย ย mousePos.x = e.clientX; 

 ย ย ย ย ย ย mousePos.y = e.clientY; 

 ย ย ย ย }); 

 ย ย ย ย window.addEventListener('touchmove', (e) => { 

 ย ย ย ย ย ย if (e.touches.length > 0) { 

 ย ย ย ย ย ย ย ย mousePos.x = e.touches[0].clientX; 

 ย ย ย ย ย ย ย ย mousePos.y = e.touches[0].clientY; 

 ย ย ย ย ย ย } 

 ย ย ย ย }, { passive: true }); 

 ย ย }); 

 ย ย </script> 

 </body> 

 </html>
